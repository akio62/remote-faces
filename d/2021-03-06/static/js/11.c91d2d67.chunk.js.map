{"version":3,"sources":["hooks/useSpatialArea.ts","components/SpatialArea.tsx","network/trackUtils.ts"],"names":["useSpatialArea","roomId","userId","statusMesg","uid","useState","avatarMap","setAvatarMap","position","parseInt","slice","myAvatar","setMyAvatar","useEffect","prev","lastMyAvatarRef","useRef","current","broadcastData","useBroadcastData","dataToBroadcast","data","spatialArea","avatarData","setTimeout","undefined","useRoomData","useCallback","x","isObject","obj","e","isAvatarData","hasStringProp","myData","Avatar","React","memo","nickname","faceStream","setPosition","distance","muted","isMyself","useThree","size","viewport","aspect","width","firstPosition","bind","useDrag","first","initial","ix","iy","xy","y","fx","fy","texture","videoTrack","setVideoTrack","stream","callback","getVideoTracks","addEventListener","removeEventListener","setTexture","videoEle","document","createElement","autoplay","srcObject","MediaStream","videoTexture","THREE","useAvatarVideo","audioTrack","setAudioTrack","getAudioTracks","setGainValueRef","defaultGainRef","gain","setGain","setGainCallback","value","audioCtx","AudioContext","destination","createMediaStreamDestination","source","createMediaStreamSource","gainNode","createGain","setValueAtTime","currentTime","connect","gainedAudioTrack","setAttribute","style","display","height","bottom","body","appendChild","a","loopbackPeerConnection","close","dispatchEvent","Event","removeChild","useAvatarAudio","d","Math","max","min","map","Text","color","fontSize","anchorX","anchorY","font","toFixed","SpatialCanvas","nicknameMap","faceStreamMap","getStatusMesg","getPosition","myPosition","fallback","Object","keys","hypot","nextPosition","SpatialArea","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","className","onChange","target","videoDevice","deviceId","label","audioDevice","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","sleep","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","canvas","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","setImage","dataURL"],"mappings":"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","file":"static/js/11.c91d2d67.chunk.js","sourcesContent":["import { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport { isObject, hasStringProp } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst getInitialPosition = (uid: string): [number, number, number] => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nexport type AvatarData = {\n  statusMesg: string;\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.statusMesg === \"string\" &&\n      typeof obj.position[0] === \"number\" &&\n      typeof obj.position[1] === \"number\" &&\n      typeof obj.position[2] === \"number\"\n    ) {\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\ntype SpatialAreaData =\n  | {\n      spatialArea: \"init\";\n    }\n  | {\n      spatialArea: \"avatar\";\n      userId: string;\n      avatarData: AvatarData;\n    };\n\nconst isSpatialAreaData = (x: unknown): x is SpatialAreaData =>\n  isObject(x) &&\n  ((x as { spatialArea: unknown }).spatialArea === \"init\" ||\n    ((x as { spatialArea: unknown }).spatialArea === \"avatar\" &&\n      isAvatarData((x as { avatarData: unknown }).avatarData) &&\n      hasStringProp(x, \"userId\")));\n\nexport const useSpatialArea = (\n  roomId: string,\n  userId: string,\n  statusMesg: string\n) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const [myAvatar, setMyAvatar] = useState<AvatarData>({\n    statusMesg,\n    position: getInitialPosition(userId),\n  });\n  useEffect(() => {\n    setMyAvatar((prev) => {\n      if (prev.statusMesg === statusMesg) {\n        return prev;\n      }\n      return { ...prev, statusMesg };\n    });\n  }, [statusMesg]);\n  const lastMyAvatarRef = useRef<AvatarData>();\n  useEffect(() => {\n    lastMyAvatarRef.current = myAvatar;\n  }, [myAvatar]);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const dataToBroadcast = useRef<SpatialAreaData>();\n  useEffect(() => {\n    if (!myAvatar) return;\n    const data: SpatialAreaData = {\n      spatialArea: \"avatar\",\n      userId,\n      avatarData: myAvatar,\n    };\n    if (dataToBroadcast.current) {\n      dataToBroadcast.current = data;\n    } else {\n      dataToBroadcast.current = data;\n      setTimeout(() => {\n        broadcastData(dataToBroadcast.current);\n        dataToBroadcast.current = undefined;\n      }, 500);\n    }\n  }, [broadcastData, userId, myAvatar]);\n\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isSpatialAreaData(data)) return;\n        if (data.spatialArea === \"init\") {\n          if (lastMyAvatarRef.current) {\n            // TODO we don't need to broadcastData but sendData is enough\n            const myData: SpatialAreaData = {\n              spatialArea: \"avatar\",\n              userId,\n              avatarData: lastMyAvatarRef.current,\n            };\n            broadcastData(myData);\n          }\n        } else {\n          setAvatarMap((prev) => ({\n            ...prev,\n            [data.userId]: data.avatarData,\n          }));\n        }\n      },\n      [broadcastData, userId]\n    )\n  );\n\n  useEffect(() => {\n    const data: SpatialAreaData = {\n      spatialArea: \"init\",\n    };\n    broadcastData(data);\n  }, [broadcastData]);\n\n  return {\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  };\n};\n","/* eslint react/jsx-props-no-spreading: off */\n\nimport React, {\n  SetStateAction,\n  Suspense,\n  useCallback,\n  useRef,\n  useState,\n  useEffect,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\nimport { Text } from \"@react-three/drei/Text\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarData, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { loopbackPeerConnection } from \"../network/trackUtils\";\n\nconst useAvatarVideo = (faceStream: MediaStream | null) => {\n  const [videoTrack, setVideoTrack] = useState<MediaStreamTrack>();\n  useEffect(() => {\n    if (faceStream) {\n      const stream = faceStream;\n      const callback = () => {\n        setVideoTrack(stream.getVideoTracks()[0]);\n      };\n      faceStream.addEventListener(\"addtrack\", callback);\n      callback();\n      return () => faceStream.removeEventListener(\"addtrack\", callback);\n    }\n    return undefined;\n  }, [faceStream]);\n  useEffect(() => {\n    if (videoTrack) {\n      videoTrack.addEventListener(\"ended\", () => {\n        setVideoTrack(undefined);\n      });\n    }\n  }, [videoTrack]);\n  const [texture, setTexture] = useState<THREE.VideoTexture>();\n  useEffect(() => {\n    if (!videoTrack) return;\n    const videoEle = document.createElement(\"video\");\n    videoEle.autoplay = true;\n    videoEle.srcObject = new MediaStream([videoTrack]);\n    const videoTexture = new THREE.VideoTexture(videoEle);\n    setTexture(videoTexture);\n  }, [videoTrack]);\n  return texture;\n};\n\nconst useAvatarAudio = (faceStream: MediaStream | null, isMyself: boolean) => {\n  const [audioTrack, setAudioTrack] = useState<MediaStreamTrack>();\n  useEffect(() => {\n    if (faceStream) {\n      const stream = faceStream;\n      const callback = () => {\n        setAudioTrack(stream.getAudioTracks()[0]);\n      };\n      faceStream.addEventListener(\"addtrack\", callback);\n      callback();\n      return () => faceStream.removeEventListener(\"addtrack\", callback);\n    }\n    return undefined;\n  }, [faceStream]);\n  useEffect(() => {\n    if (audioTrack) {\n      audioTrack.addEventListener(\"ended\", () => {\n        setAudioTrack(undefined);\n      });\n    }\n  }, [audioTrack]);\n  const setGainValueRef = useRef<((value: number) => void) | null>(null);\n  const defaultGainRef = useRef(0.5);\n  const [gain, setGain] = useState<number | null>(null);\n  const setGainCallback = useCallback((value: number) => {\n    if (setGainValueRef.current) {\n      setGain(value);\n      setGainValueRef.current(value);\n    } else {\n      setGain(null);\n      defaultGainRef.current = value;\n    }\n  }, []);\n  useEffect(() => {\n    if (isMyself || !audioTrack) return undefined;\n    const audioCtx = new AudioContext();\n    const destination = audioCtx.createMediaStreamDestination();\n    const source = audioCtx.createMediaStreamSource(\n      new MediaStream([audioTrack])\n    );\n    const gainNode = audioCtx.createGain();\n    gainNode.gain.value = defaultGainRef.current;\n    setGain(defaultGainRef.current);\n    setGainValueRef.current = (value: number) => {\n      gainNode.gain.setValueAtTime(value, audioCtx.currentTime);\n    };\n    source.connect(gainNode);\n    gainNode.connect(destination);\n    const gainedAudioTrack = destination.stream.getAudioTracks()[0];\n    const videoEle = document.createElement(\"video\");\n    videoEle.autoplay = true;\n    videoEle.setAttribute(\"playsinline\", \"\");\n    videoEle.style.display = \"block\";\n    videoEle.style.width = \"1px\";\n    videoEle.style.height = \"1px\";\n    videoEle.style.position = \"absolute\";\n    videoEle.style.bottom = \"0px\";\n    document.body.appendChild(videoEle);\n    (async () => {\n      videoEle.srcObject = new MediaStream([\n        await loopbackPeerConnection(gainedAudioTrack),\n      ]);\n    })();\n    return () => {\n      setGainValueRef.current = null;\n      setGain(null);\n      audioCtx.close();\n      gainedAudioTrack.dispatchEvent(new Event(\"ended\"));\n      document.body.removeChild(videoEle);\n    };\n  }, [isMyself, audioTrack]);\n  return [gain, setGainCallback] as const;\n};\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  statusMesg: string;\n  position: [number, number, number];\n  setPosition?: (nextPosition: [number, number, number]) => void;\n  distance?: number;\n  muted?: boolean;\n}>(\n  ({\n    nickname,\n    faceStream,\n    statusMesg,\n    position,\n    setPosition,\n    distance,\n    muted,\n  }) => {\n    const isMyself = !!setPosition;\n    const { size, viewport } = useThree();\n    const aspect = size.width / viewport.width;\n    const firstPosition = useRef<[number, number, number]>();\n    const bind = useDrag(({ first, initial: [ix, iy], xy: [x, y] }) => {\n      if (first) {\n        firstPosition.current = position;\n      }\n      const [fx, fy] = firstPosition.current as [number, number, number];\n      if (setPosition) {\n        setPosition([fx + (x - ix) / aspect, fy - (y - iy) / aspect, 0]);\n      }\n    });\n    const texture = useAvatarVideo(faceStream);\n    const [gain, setGain] = useAvatarAudio(faceStream, isMyself);\n    useEffect(() => {\n      if (distance === undefined || muted) {\n        setGain(0.0);\n        return;\n      }\n      const d = Math.max(0.0, distance - 0.2);\n      setGain(Math.min(1.0, Math.max(0.0, 1.0 / (d * d) - 0.1)));\n    }, [muted, distance, setGain]);\n    if (!texture) return null;\n    return (\n      <>\n        <sprite {...(isMyself && bind())} position={position}>\n          <spriteMaterial map={texture} />\n        </sprite>\n        <Text\n          color=\"blue\"\n          fontSize={0.3}\n          anchorX=\"left\"\n          anchorY=\"top\"\n          position={[position[0] - 0.5, position[1] + 0.5, position[2]]}\n        >\n          {nickname}\n        </Text>\n        <Text\n          color=\"darkgreen\"\n          fontSize={0.3}\n          anchorX=\"left\"\n          anchorY=\"middle\"\n          font=\"https://fonts.gstatic.com/ea/notosansjapanese/v6/NotoSansJP-Bold.woff\"\n          position={[position[0] - 0.5, position[1], position[2]]}\n        >\n          {statusMesg}\n        </Text>\n        {gain !== null && (\n          <Text\n            color=\"red\"\n            fontSize={0.3}\n            anchorX=\"left\"\n            anchorY=\"bottom\"\n            position={[position[0] - 0.5, position[1] - 0.5, position[2]]}\n          >\n            {gain.toFixed(2)}\n          </Text>\n        )}\n      </>\n    );\n  }\n);\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  myAvatar?: AvatarData;\n  setMyAvatar: (action: SetStateAction<AvatarData>) => void;\n}>(\n  ({\n    userId,\n    nickname,\n    statusMesg,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  }) => {\n    const getStatusMesg = (uid: string) => avatarMap[uid]?.statusMesg || \"\";\n    const getPosition = (uid: string) => avatarMap[uid]?.position || [0, 0, 0];\n\n    const setMyPosition = (nextPosition: [number, number, number]) => {\n      setMyAvatar((prev) => ({ ...prev, position: nextPosition }));\n    };\n    const myPosition = myAvatar?.position || [0, 0, 0];\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map((uid) => {\n            if (uid === userId) return null;\n            const position = getPosition(uid);\n            const distance = Math.hypot(\n              position[0] - myPosition[0],\n              position[1] - myPosition[1],\n              position[2] - myPosition[2]\n            );\n            return (\n              <Avatar\n                key={uid}\n                nickname={nicknameMap[uid] || \"\"}\n                faceStream={faceStreamMap[uid] || null}\n                statusMesg={getStatusMesg(uid)}\n                position={getPosition(uid)}\n                distance={distance}\n              />\n            );\n          })}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            statusMesg={statusMesg}\n            position={myPosition}\n            setPosition={setMyPosition}\n            muted\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n}>(({ roomId, userId, nickname, statusMesg }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, myAvatar, setMyAvatar } = useSpatialArea(\n    roomId,\n    userId,\n    statusMesg\n  );\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          statusMesg={statusMesg}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          myAvatar={myAvatar}\n          setMyAvatar={setMyAvatar}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n"],"sourceRoot":""}