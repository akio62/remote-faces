{"version":3,"sources":["media/screen.ts","hooks/useScreenShare.ts","components/ScreenShare.tsx","hooks/useNicknameMap.ts"],"names":["getScreenStream","a","constraints","video","navigator","mediaDevices","getDisplayMedia","stream","getVideoTracks","track","dispose","stop","videoType","Screen","React","memo","nickname","videoRef","useRef","useEffect","current","srcObject","className","ref","autoPlay","muted","ScreenShare","roomId","userId","useState","enabled","setEnabled","screenStream","setScreenStream","screenStreamMap","setScreenStreamMap","cleanupFns","forEach","fn","trackMap","useSnapshot","getRoomState","Object","entries","uid","readyState","getTracks","includes","prev","MediaStream","onended","addEventListener","push","removeEventListener","roomState","addMediaType","removeMediaType","cleanup","result","addTrack","removeTrack","useScreenShare","nicknameMap","useNicknameMap","type","onClick","keys","map","screenUserId","setNicknameMap","ydoc","getMap","listener","copied","changed","data","x","isObject","info","observe","unobserve"],"mappings":"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","file":"static/js/19.f601a895.chunk.js","sourcesContent":["export const getScreenStream = async () => {\n  try {\n    const constraints = { video: true };\n    const stream = (await (navigator.mediaDevices as any).getDisplayMedia(\n      constraints\n    )) as MediaStream;\n    const [track] = stream.getVideoTracks();\n    const dispose = () => {\n      track.stop();\n    };\n    return {\n      stream,\n      dispose,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n","import { useEffect, useState, useRef } from \"react\";\nimport { useSnapshot } from \"valtio\";\n\nimport { getScreenStream } from \"../media/screen\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst videoType = \"screenVideo\";\n\nexport const useScreenShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void\n) => {\n  const [screenStream, setScreenStream] = useState<MediaStream | null>(null);\n  const [screenStreamMap, setScreenStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = ([uid, track]: [string, MediaStreamTrack]) => {\n    if (track.readyState === \"ended\") return;\n    if (screenStreamMap[uid]?.getTracks().includes(track)) return;\n    setScreenStreamMap((prev) => ({\n      ...prev,\n      [uid]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setScreenStreamMap((prev) => ({\n        ...prev,\n        [uid]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  };\n\n  const trackMap = useSnapshot(getRoomState(roomId, userId).trackMap);\n  Object.entries(trackMap[videoType] || {}).forEach(onTrack);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    roomState.addMediaType(videoType);\n    return () => {\n      roomState.removeMediaType(videoType);\n    };\n  }, [roomId, userId]);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    let cleanup: (() => void) | null | false = null;\n    if (enabled) {\n      (async () => {\n        const result = await getScreenStream();\n        if (!result) {\n          setEnabled(false);\n          return;\n        }\n        const [track] = result.stream.getVideoTracks();\n        roomState.addTrack(videoType, track);\n        setScreenStream(result.stream);\n        track.addEventListener(\"ended\", () => {\n          if (cleanup) cleanup();\n          cleanup = null;\n        });\n        const dispose = () => {\n          roomState.removeTrack(videoType);\n          result.dispose();\n          setScreenStream(null);\n          setEnabled(false);\n        };\n        if (cleanup === false) {\n          dispose();\n        } else {\n          cleanup = dispose;\n        }\n      })();\n    }\n    return () => {\n      if (cleanup) cleanup();\n      cleanup = false;\n    };\n  }, [roomId, userId, enabled, setEnabled]);\n\n  return { screenStream, screenStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./ScreenShare.css\";\nimport { useScreenShare } from \"../hooks/useScreenShare\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Screen = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"ScreenShare-nickname\">{nickname}</div>\n      <video className=\"ScreenShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\nexport const ScreenShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const [enabled, setEnabled] = useState(false);\n  const { screenStream, screenStreamMap } = useScreenShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n\n  return (\n    <div className=\"ScreenShare-container\">\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop screen share\" : \"Start screen share\"}\n      </button>\n      <div className=\"ScreenShare-body\">\n        {screenStream && <Screen nickname={nickname} stream={screenStream} />}\n        {Object.keys(screenStreamMap).map((screenUserId) => {\n          const stream = screenStreamMap[screenUserId];\n          if (!stream) return null;\n          return (\n            <Screen\n              key={screenUserId}\n              nickname={nicknameMap[screenUserId] || \"No Name\"}\n              stream={stream}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n\nexport default ScreenShare;\n","import { useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\ntype NicknameMap = {\n  [userId: string]: string;\n};\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<NicknameMap>({});\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    const map = roomState.ydoc.getMap(\"faceImages\");\n    const listener = () => {\n      setNicknameMap((prev) => {\n        const copied = { ...prev };\n        let changed = false;\n        map.forEach((data, uid) => {\n          if (uid === userId) return;\n          if (!hasInfoNickname(data)) return;\n          if (!copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          } else if (data.info.nickname !== copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          }\n        });\n        if (changed) {\n          return copied;\n        }\n        return prev;\n      });\n    };\n    map.observe(listener);\n    listener();\n    return () => {\n      map.unobserve(listener);\n    };\n  }, [roomId, userId]);\n\n  return nicknameMap;\n};\n"],"sourceRoot":""}