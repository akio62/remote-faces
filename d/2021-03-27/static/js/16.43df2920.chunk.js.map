{"version":3,"sources":["components/SpatialArea.tsx","hooks/useSpatialArea.ts","network/trackUtils.ts","hooks/useNicknameMap.ts"],"names":["Avatar","React","memo","nickname","faceStream","statusMesg","position","setPosition","distance","muted","isMyself","useThree","size","viewport","aspect","width","firstPosition","useRef","bind","useDrag","first","initial","ix","iy","xy","x","y","current","fx","fy","texture","useState","videoTrack","setVideoTrack","useEffect","stream","callback","getVideoTracks","addEventListener","removeEventListener","undefined","setTexture","videoEle","document","createElement","autoplay","srcObject","MediaStream","videoTexture","THREE","useAvatarVideo","audioTrack","setAudioTrack","getAudioTracks","setGainValueRef","defaultGainRef","gain","setGain","setGainCallback","useCallback","value","audioCtx","AudioContext","destination","createMediaStreamDestination","source","createMediaStreamSource","gainNode","createGain","setValueAtTime","currentTime","connect","gainedAudioTrack","setAttribute","style","display","height","bottom","body","appendChild","a","loopbackPeerConnection","close","dispatchEvent","Event","removeChild","useAvatarAudio","d","Math","max","min","map","Text","color","fontSize","anchorX","anchorY","font","toFixed","SpatialCanvas","userId","nicknameMap","faceStreamMap","avatarMap","myAvatar","setMyAvatar","getStatusMesg","uid","getPosition","myPosition","fallback","Object","keys","hypot","nextPosition","prev","SpatialArea","roomId","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","setAvatarMap","parseInt","slice","roomState","getRoomState","ydoc","getMap","listener","copied","changed","forEach","data","b","userIdMap","obj","e","isAvatarData","observe","unsub","subscribe","unobserve","dataToBroadcast","setTimeout","set","useSpatialArea","className","onChange","target","videoDevice","deviceId","label","audioDevice","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","onmute","timeout","readyState","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","canvas","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","setImage","dataURL","setNicknameMap","isObject","info"],"mappings":"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","file":"static/js/16.43df2920.chunk.js","sourcesContent":["/* eslint react/jsx-props-no-spreading: off */\n\nimport React, {\n  SetStateAction,\n  Suspense,\n  useCallback,\n  useRef,\n  useState,\n  useEffect,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\nimport { Text } from \"@react-three/drei/Text\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarData, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { loopbackPeerConnection } from \"../network/trackUtils\";\n\nconst useAvatarVideo = (faceStream: MediaStream | null) => {\n  const [videoTrack, setVideoTrack] = useState<MediaStreamTrack>();\n  useEffect(() => {\n    if (faceStream) {\n      const stream = faceStream;\n      const callback = () => {\n        setVideoTrack(stream.getVideoTracks()[0]);\n      };\n      faceStream.addEventListener(\"addtrack\", callback);\n      callback();\n      return () => faceStream.removeEventListener(\"addtrack\", callback);\n    }\n    return undefined;\n  }, [faceStream]);\n  useEffect(() => {\n    if (videoTrack) {\n      videoTrack.addEventListener(\"ended\", () => {\n        setVideoTrack(undefined);\n      });\n    }\n  }, [videoTrack]);\n  const [texture, setTexture] = useState<THREE.VideoTexture>();\n  useEffect(() => {\n    if (!videoTrack) return;\n    const videoEle = document.createElement(\"video\");\n    videoEle.autoplay = true;\n    videoEle.srcObject = new MediaStream([videoTrack]);\n    const videoTexture = new THREE.VideoTexture(videoEle);\n    setTexture(videoTexture);\n  }, [videoTrack]);\n  return texture;\n};\n\nconst useAvatarAudio = (faceStream: MediaStream | null, isMyself: boolean) => {\n  const [audioTrack, setAudioTrack] = useState<MediaStreamTrack>();\n  useEffect(() => {\n    if (faceStream) {\n      const stream = faceStream;\n      const callback = () => {\n        setAudioTrack(stream.getAudioTracks()[0]);\n      };\n      faceStream.addEventListener(\"addtrack\", callback);\n      callback();\n      return () => faceStream.removeEventListener(\"addtrack\", callback);\n    }\n    return undefined;\n  }, [faceStream]);\n  useEffect(() => {\n    if (audioTrack) {\n      audioTrack.addEventListener(\"ended\", () => {\n        setAudioTrack(undefined);\n      });\n    }\n  }, [audioTrack]);\n  const setGainValueRef = useRef<((value: number) => void) | null>(null);\n  const defaultGainRef = useRef(0.5);\n  const [gain, setGain] = useState<number | null>(null);\n  const setGainCallback = useCallback((value: number) => {\n    if (setGainValueRef.current) {\n      setGain(value);\n      setGainValueRef.current(value);\n    } else {\n      setGain(null);\n      defaultGainRef.current = value;\n    }\n  }, []);\n  useEffect(() => {\n    if (isMyself || !audioTrack) return undefined;\n    const audioCtx = new AudioContext();\n    const destination = audioCtx.createMediaStreamDestination();\n    const source = audioCtx.createMediaStreamSource(\n      new MediaStream([audioTrack])\n    );\n    const gainNode = audioCtx.createGain();\n    gainNode.gain.value = defaultGainRef.current;\n    setGain(defaultGainRef.current);\n    setGainValueRef.current = (value: number) => {\n      gainNode.gain.setValueAtTime(value, audioCtx.currentTime);\n    };\n    source.connect(gainNode);\n    gainNode.connect(destination);\n    const gainedAudioTrack = destination.stream.getAudioTracks()[0];\n    const videoEle = document.createElement(\"video\");\n    videoEle.autoplay = true;\n    videoEle.setAttribute(\"playsinline\", \"\");\n    videoEle.style.display = \"block\";\n    videoEle.style.width = \"1px\";\n    videoEle.style.height = \"1px\";\n    videoEle.style.position = \"absolute\";\n    videoEle.style.bottom = \"0px\";\n    document.body.appendChild(videoEle);\n    (async () => {\n      videoEle.srcObject = new MediaStream([\n        await loopbackPeerConnection(gainedAudioTrack),\n      ]);\n    })();\n    return () => {\n      setGainValueRef.current = null;\n      setGain(null);\n      audioCtx.close();\n      gainedAudioTrack.dispatchEvent(new Event(\"ended\"));\n      document.body.removeChild(videoEle);\n    };\n  }, [isMyself, audioTrack]);\n  return [gain, setGainCallback] as const;\n};\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  statusMesg: string;\n  position: [number, number, number];\n  setPosition?: (nextPosition: [number, number, number]) => void;\n  distance?: number;\n  muted?: boolean;\n}>(\n  ({\n    nickname,\n    faceStream,\n    statusMesg,\n    position,\n    setPosition,\n    distance,\n    muted,\n  }) => {\n    const isMyself = !!setPosition;\n    const { size, viewport } = useThree();\n    const aspect = size.width / viewport.width;\n    const firstPosition = useRef<[number, number, number]>();\n    const bind = useDrag(({ first, initial: [ix, iy], xy: [x, y] }) => {\n      if (first) {\n        firstPosition.current = position;\n      }\n      const [fx, fy] = firstPosition.current as [number, number, number];\n      if (setPosition) {\n        setPosition([fx + (x - ix) / aspect, fy - (y - iy) / aspect, 0]);\n      }\n    });\n    const texture = useAvatarVideo(faceStream);\n    const [gain, setGain] = useAvatarAudio(faceStream, isMyself);\n    useEffect(() => {\n      if (distance === undefined || muted) {\n        setGain(0.0);\n        return;\n      }\n      const d = Math.max(0.0, distance - 0.2);\n      setGain(Math.min(1.0, Math.max(0.0, 1.0 / (d * d) - 0.1)));\n    }, [muted, distance, setGain]);\n    if (!texture) return null;\n    return (\n      <>\n        <sprite {...(isMyself && bind())} position={position}>\n          <spriteMaterial map={texture} />\n        </sprite>\n        <Text\n          color=\"blue\"\n          fontSize={0.3}\n          anchorX=\"left\"\n          anchorY=\"top\"\n          position={[position[0] - 0.5, position[1] + 0.5, position[2]]}\n        >\n          {nickname}\n        </Text>\n        <Text\n          color=\"darkgreen\"\n          fontSize={0.3}\n          anchorX=\"left\"\n          anchorY=\"middle\"\n          font=\"https://fonts.gstatic.com/ea/notosansjapanese/v6/NotoSansJP-Bold.woff\"\n          position={[position[0] - 0.5, position[1], position[2]]}\n        >\n          {statusMesg}\n        </Text>\n        {gain !== null && (\n          <Text\n            color=\"red\"\n            fontSize={0.3}\n            anchorX=\"left\"\n            anchorY=\"bottom\"\n            position={[position[0] - 0.5, position[1] - 0.5, position[2]]}\n          >\n            {gain.toFixed(2)}\n          </Text>\n        )}\n      </>\n    );\n  }\n);\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  myAvatar?: AvatarData;\n  setMyAvatar: (action: SetStateAction<AvatarData>) => void;\n}>(\n  ({\n    userId,\n    nickname,\n    statusMesg,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  }) => {\n    const getStatusMesg = (uid: string) => avatarMap[uid]?.statusMesg || \"\";\n    const getPosition = (uid: string) => avatarMap[uid]?.position || [0, 0, 0];\n\n    const setMyPosition = (nextPosition: [number, number, number]) => {\n      setMyAvatar((prev) => ({ ...prev, position: nextPosition }));\n    };\n    const myPosition = myAvatar?.position || [0, 0, 0];\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map((uid) => {\n            if (uid === userId) return null;\n            const position = getPosition(uid);\n            const distance = Math.hypot(\n              position[0] - myPosition[0],\n              position[1] - myPosition[1],\n              position[2] - myPosition[2]\n            );\n            return (\n              <Avatar\n                key={uid}\n                nickname={nicknameMap[uid] || \"\"}\n                faceStream={faceStreamMap[uid] || null}\n                statusMesg={getStatusMesg(uid)}\n                position={getPosition(uid)}\n                distance={distance}\n              />\n            );\n          })}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            statusMesg={statusMesg}\n            position={myPosition}\n            setPosition={setMyPosition}\n            muted\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n}>(({ roomId, userId, nickname, statusMesg }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, myAvatar, setMyAvatar } = useSpatialArea(\n    roomId,\n    userId,\n    statusMesg\n  );\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          statusMesg={statusMesg}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          myAvatar={myAvatar}\n          setMyAvatar={setMyAvatar}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n","import { useState, useRef, useEffect } from \"react\";\nimport { subscribe } from \"valtio\";\n\nimport { getRoomState } from \"../states/roomMap\";\n\nconst getInitialPosition = (uid: string): [number, number, number] => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nexport type AvatarData = {\n  statusMesg: string;\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.statusMesg === \"string\" &&\n      typeof obj.position[0] === \"number\" &&\n      typeof obj.position[1] === \"number\" &&\n      typeof obj.position[2] === \"number\"\n    ) {\n      return true;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isEqualAvatarData = (a: AvatarData, b: AvatarData) =>\n  a.statusMesg === b.statusMesg &&\n  a.position[0] === b.position[0] &&\n  a.position[1] === b.position[1] &&\n  a.position[2] === b.position[2];\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\nexport const useSpatialArea = (\n  roomId: string,\n  userId: string,\n  statusMesg: string\n) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const [myAvatar, setMyAvatar] = useState<AvatarData>({\n    statusMesg,\n    position: getInitialPosition(userId),\n  });\n  useEffect(() => {\n    setMyAvatar((prev) => {\n      if (prev.statusMesg === statusMesg) {\n        return prev;\n      }\n      return { ...prev, statusMesg };\n    });\n  }, [statusMesg]);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    const map = roomState.ydoc.getMap(\"spatialArea\");\n    const listener = () => {\n      setAvatarMap((prev) => {\n        const copied = { ...prev };\n        let changed = false;\n        map.forEach((data, uid) => {\n          if (uid === userId) return;\n          if (!roomState.userIdMap[uid]) return;\n          if (!isAvatarData(data)) return;\n          if (!copied[uid]) {\n            copied[uid] = data;\n            changed = true;\n          } else if (!isEqualAvatarData(data, copied[uid])) {\n            copied[uid] = data;\n            changed = true;\n          }\n        });\n        Object.keys(copied).forEach((uid) => {\n          if (!roomState.userIdMap[uid]) {\n            delete copied[uid];\n            changed = true;\n          }\n        });\n        if (changed) {\n          return copied;\n        }\n        return prev;\n      });\n    };\n    map.observe(listener);\n    const unsub = subscribe(roomState.userIdMap, listener);\n    listener();\n    return () => {\n      unsub();\n      map.unobserve(listener);\n    };\n  }, [roomId, userId]);\n\n  const dataToBroadcast = useRef<AvatarData>();\n  useEffect(() => {\n    if (!myAvatar) return;\n    if (dataToBroadcast.current) {\n      dataToBroadcast.current = myAvatar;\n    } else {\n      dataToBroadcast.current = myAvatar;\n      setTimeout(() => {\n        const roomState = getRoomState(roomId, userId);\n        const map = roomState.ydoc.getMap(\"spatialArea\");\n        map.set(userId, dataToBroadcast.current);\n        dataToBroadcast.current = undefined;\n      }, 500);\n    }\n  }, [roomId, userId, myAvatar]);\n\n  return {\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import { useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\ntype NicknameMap = {\n  [userId: string]: string;\n};\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<NicknameMap>({});\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    const map = roomState.ydoc.getMap(\"faceImages\");\n    const listener = () => {\n      setNicknameMap((prev) => {\n        const copied = { ...prev };\n        let changed = false;\n        map.forEach((data, uid) => {\n          if (uid === userId) return;\n          if (!hasInfoNickname(data)) return;\n          if (!copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          } else if (data.info.nickname !== copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          }\n        });\n        if (changed) {\n          return copied;\n        }\n        return prev;\n      });\n    };\n    map.observe(listener);\n    listener();\n    return () => {\n      map.unobserve(listener);\n    };\n  }, [roomId, userId]);\n\n  return nicknameMap;\n};\n"],"sourceRoot":""}