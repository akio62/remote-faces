{"version":3,"sources":["hooks/useSpatialArea.ts","components/SpatialArea.tsx"],"names":["isAvatarData","x","obj","position","e","isAreaData","isObject","Object","values","every","isAvatarMap","avatarMap","updatedAt","useSpatialArea","roomId","userId","useState","setAvatarMap","lastAreaDataRef","useRef","timerRef","broadcastData","useBroadcastData","useEffect","current","Date","now","data","spatialArea","areaData","clearTimeout","setTimeout","useRoomData","useCallback","prev","prevKeys","keys","nextKeys","length","key","a","b","Avatar","React","memo","nickname","faceStream","setPosition","useThree","size","viewport","aspect","width","bind","useDrag","delta","y","eventOptions","pointer","texture","setTexture","videoTrack","getVideoTracks","canvas","document","createElement","canvasTexture","THREE","imageCapture","ImageCapture","ctx","getContext","timer","setInterval","grabFrame","bitmap","height","drawImage","font","textBaseline","fillStyle","fillText","needsUpdate","clearInterval","map","getInitialPosition","uid","parseInt","slice","SpatialCanvas","nicknameMap","faceStreamMap","getPosition","update","fallback","SpatialArea","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","className","value","onChange","target","videoDevice","deviceId","label","audioDevice"],"mappings":"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","file":"static/js/16.82894086.chunk.js","sourcesContent":["import { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\ntype AvatarData = {\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.position[0] !== \"number\" ||\n      typeof obj.position[1] !== \"number\" ||\n      typeof obj.position[2] !== \"number\"\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isEqualAvatarData = (a: AvatarData, b: AvatarData) =>\n  a.position[0] === b.position[0] &&\n  a.position[1] === b.position[1] &&\n  a.position[2] === b.position[2];\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\nconst isAvatarMap = (x: unknown): x is AvatarMap =>\n  isObject(x) && Object.values(x).every(isAvatarData);\n\ntype AreaData = {\n  avatarMap: AvatarMap;\n  updatedAt: number; // in millisecond\n};\n\nconst isAreaData = (x: unknown): x is AreaData =>\n  isObject(x) &&\n  isAvatarMap(x.avatarMap) &&\n  typeof (x as { updatedAt: unknown }).updatedAt === \"number\";\n\ntype SpatialAreaData =\n  | {\n      spatialArea: \"init\";\n    }\n  | {\n      spatialArea: \"sync\";\n      areaData: AreaData;\n    };\n\nconst isSpatialAreaData = (x: unknown): x is SpatialAreaData =>\n  isObject(x) &&\n  ((x as { spatialArea: unknown }).spatialArea === \"init\" ||\n    ((x as { spatialArea: unknown }).spatialArea === \"sync\" &&\n      isAreaData((x as { areaData: unknown }).areaData)));\n\nexport const useSpatialArea = (roomId: string, userId: string) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const lastAreaDataRef = useRef<AreaData>();\n  const timerRef = useRef<NodeJS.Timeout>();\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useEffect(() => {\n    lastAreaDataRef.current = {\n      avatarMap,\n      updatedAt: Date.now(),\n    };\n    const data: SpatialAreaData = {\n      spatialArea: \"sync\",\n      areaData: lastAreaDataRef.current,\n    };\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n    timerRef.current = setTimeout(() => {\n      broadcastData(data);\n    }, 100);\n  }, [broadcastData, avatarMap]);\n\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isSpatialAreaData(data)) return;\n        if (data.spatialArea === \"init\") {\n          if (lastAreaDataRef.current) {\n            // TODO we don't need to broadcastData but sendData is enough\n            broadcastData({\n              spatialArea: \"sync\",\n              areaData: lastAreaDataRef.current,\n            });\n          }\n          return;\n        }\n        // FIXME why do we need this type assertion?\n        const { areaData } = data as { areaData: AreaData };\n        if (\n          lastAreaDataRef.current &&\n          lastAreaDataRef.current.updatedAt > areaData.updatedAt\n        ) {\n          return;\n        }\n        setAvatarMap((prev) => {\n          const prevKeys = Object.keys(prev);\n          const nextKeys = Object.keys(areaData.avatarMap);\n          if (\n            prevKeys.length === nextKeys.length &&\n            prevKeys.every((key) =>\n              isEqualAvatarData(prev[key], areaData.avatarMap[key])\n            )\n          ) {\n            // bail out\n            return prev;\n          }\n          return {\n            ...prev,\n            ...areaData.avatarMap,\n          };\n        });\n      },\n      [broadcastData]\n    )\n  );\n\n  useEffect(() => {\n    broadcastData({\n      spatialArea: \"init\",\n    });\n  }, [broadcastData]);\n\n  return {\n    avatarMap,\n    setAvatarMap,\n  };\n};\n","/* eslint react/jsx-props-no-spreading: off */\n\nimport React, {\n  Suspense,\n  Dispatch,\n  SetStateAction,\n  useState,\n  useEffect,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  position: [number, number, number];\n  setPosition: Dispatch<SetStateAction<[number, number, number]>>;\n}>(({ nickname, faceStream, position, setPosition }) => {\n  const { size, viewport } = useThree();\n  const aspect = size.width / viewport.width;\n  const bind = useDrag(\n    ({ delta: [x, y] }) =>\n      setPosition((prev) => [prev[0] + x / aspect, prev[1] - y / aspect, 0]),\n    { eventOptions: { pointer: true } }\n  );\n  const [texture, setTexture] = useState<THREE.CanvasTexture>();\n  useEffect(() => {\n    const videoTrack = faceStream?.getVideoTracks()[0];\n    if (!videoTrack) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const canvasTexture = new THREE.CanvasTexture(canvas);\n    setTexture(canvasTexture);\n    const imageCapture = new ImageCapture(videoTrack);\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    const timer = setInterval(async () => {\n      try {\n        const bitmap = await imageCapture.grabFrame();\n        canvas.width = bitmap.width;\n        canvas.height = bitmap.height;\n        ctx.drawImage(bitmap, 0, 0);\n        ctx.font = \"18px selif\";\n        ctx.textBaseline = \"top\";\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(nickname, 2, 2);\n        canvasTexture.needsUpdate = true;\n      } catch (e) {\n        // ignore\n      }\n    }, 1000 / 7.5);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [nickname, faceStream]);\n  if (!texture) return null;\n  return (\n    <sprite {...bind()} position={position}>\n      <spriteMaterial map={texture} />\n    </sprite>\n  );\n});\n\nconst getInitialPosition = (uid: string) => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  setAvatarMap: Dispatch<SetStateAction<AvatarMap>>;\n}>(\n  ({\n    userId,\n    nickname,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    setAvatarMap,\n  }) => {\n    const getPosition = (uid: string) =>\n      avatarMap[uid]?.position || getInitialPosition(uid);\n\n    const setPosition = (uid: string) => (\n      update: SetStateAction<[number, number, number]>\n    ) => {\n      setAvatarMap((prev) => ({\n        ...prev,\n        [uid]: {\n          ...prev[uid],\n          position:\n            typeof update === \"function\"\n              ? update(prev[uid]?.position || getInitialPosition(uid))\n              : update,\n        },\n      }));\n    };\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map((uid) => (\n            <Avatar\n              key={uid}\n              nickname={nicknameMap[uid] || \"\"}\n              faceStream={faceStreamMap[uid] || null}\n              position={getPosition(uid)}\n              setPosition={setPosition(uid)}\n            />\n          ))}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            position={getPosition(userId)}\n            setPosition={setPosition(userId)}\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, setAvatarMap } = useSpatialArea(roomId, userId);\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          setAvatarMap={setAvatarMap}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n"],"sourceRoot":""}