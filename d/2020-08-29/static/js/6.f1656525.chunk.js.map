{"version":3,"sources":["utils/sleep.ts","network/trackUtils.ts","network/ipfsUtils.ts","network/ipfsRoom.ts","utils/types.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","createConnectionMap","map","Map","registerRemoteMediaTypeFromSDP","conn","msid2mediaType","sdpLines","mid","value","get","peer","split","forEach","line","startsWith","slice","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","Error","peerIndex","sendPc","recvPc","getConn","findConn","Array","from","values","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEachConnsAcceptingMedia","includes","size","getRemoteMediaType","registerRemoteMediaType","sdp","hasObjectProp","hasStringProp","createRoom","roomId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myIpfs","myPeerId","myIpfsPubSubRoom","connMap","roomTopic","ROOM_ID_PREFIX_LEN","importCryptoKey","cryptoKey","showConnectedStatus","peerIndexList","type","parsePayload","encrypted","JSON","decrypt","payload","parse","console","log","info","undefined","sendPayload","topic","encrypt","stringify","byteLength","warn","broadcast","error","sendPayloadDirectly","sendTo","broadcastData","data","sendData","acceptMediaTypes","mTypes","transceivers","getReceivers","mType","readyState","sendSDP","getMsid2MediaType","SDP","handlePayloadSDP","isObject","negotiationId","negotiationIdMap","startNegotiation","running","secureRandomId","negotiate","sendIce","ice","ICE","handlePayloadIce","direction","e","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","x","syncAllTracks","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","pubsubHandler","msg","Ipfs","create","repo","config","Addresses","Swarm","ipfs","id","IpfsPubSubRoom","on","initIpfs","closeIpfs","ipfsPubSubRoom","leave","mediaTypeMap","stream","MediaStream","name","removeTrack","item","sender","getSenders","s","senders","some","dispose","prop"],"mappings":"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","file":"static/js/6.f1656525.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","import { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nlet peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  const getRemoteMediaType = (conn: Connection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Connection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Connection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Ipfs, { IpfsType, PubsubHandler } from \"ipfs\";\nimport IpfsPubSubRoom from \"ipfs-pubsub-room\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  secureRandomId,\n  importCryptoKey,\n  encrypt,\n  decrypt,\n} from \"../utils/crypto\";\nimport { isObject, hasStringProp, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myIpfs: IpfsType | null = null;\n  let myPeerId: string | null = null;\n  let myIpfsPubSubRoom: IpfsPubSubRoom | null = null;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const payload = JSON.parse(await decrypt(encrypted, cryptoKey));\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      const encrypted = await encrypt(JSON.stringify(payload), cryptoKey);\n      console.log(\"sending encrypted\", encrypted.byteLength);\n      if (encrypted.byteLength > 262144) {\n        console.warn(\"encrypted message too large, aborting\");\n        return;\n      }\n      if (!myIpfs) {\n        console.warn(\"no myIpfs initialized\");\n        return;\n      }\n      if (myIpfsPubSubRoom) {\n        myIpfsPubSubRoom.broadcast(encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(JSON.stringify(payload), cryptoKey);\n      if (myIpfsPubSubRoom) {\n        myIpfsPubSubRoom.sendTo(conn.peer, encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayloadDirectly\", e);\n    }\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConns((conn) => {\n        const info: PeerInfo = {\n          userId: conn.userId,\n          peerIndex: conn.peerIndex,\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        const transceivers = conn.recvPc.getTransceivers();\n        conn.recvPc.getReceivers().forEach((receiver) => {\n          const transceiver = transceivers.find((t) => t.receiver === receiver);\n          const mid = transceiver?.mid;\n          const mType = mid && connMap.getRemoteMediaType(conn, mid);\n          if (!mType) {\n            console.warn(\"failed to find media type from mid\");\n            return;\n          }\n          if (\n            receiver.track.readyState === \"live\" &&\n            !mediaTypes.includes(mType) &&\n            mTypes.includes(mType)\n          ) {\n            receiveTrack(\n              mType,\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          }\n        });\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const sendSDP = async (\n    conn: Connection,\n    sdp:\n      | {\n          negotiationId: string;\n          offer: RTCSessionDescriptionInit;\n        }\n      | {\n          negotiationId: string;\n          answer: RTCSessionDescriptionInit;\n        }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    await sendPayloadDirectly(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (!hasStringProp(sdp, \"negotiationId\")) {\n      console.warn(\"negotiationId not found in SDP\");\n      return;\n    }\n    const { negotiationId } = sdp;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.recvPc.setRemoteDescription(sdp.offer);\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { negotiationId, answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      if (negotiationIdMap.get(conn) === negotiationId) {\n        negotiationIdMap.delete(conn);\n      }\n      try {\n        await conn.sendPc.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const negotiationIdMap = new WeakMap<Connection, string>();\n  const startNegotiation = (conn: Connection) => {\n    const running = negotiationIdMap.has(conn);\n    negotiationIdMap.set(conn, secureRandomId());\n    if (running) return;\n    const negotiate = async () => {\n      const negotiationId = negotiationIdMap.get(conn);\n      if (!negotiationId) return;\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      await sendSDP(conn, { negotiationId, offer });\n      await sleep(5000);\n      negotiate();\n    };\n    negotiate();\n  };\n\n  const sendIce = (\n    conn: Connection,\n    ice: {\n      direction: \"send\" | \"recv\";\n      candidate: RTCIceCandidate;\n    }\n  ) => {\n    sendPayloadDirectly(conn, { ICE: ice });\n  };\n\n  const handlePayloadIce = (conn: Connection, ice: unknown) => {\n    if (!isObject(ice)) return;\n    if (!hasStringProp(ice, \"direction\")) {\n      console.warn(\"direction not found in ICE\");\n      return;\n    }\n    if (!hasObjectProp(ice, \"candidate\")) {\n      console.warn(\"candidate not found in ICE\");\n      return;\n    }\n    try {\n      if (ice.direction === \"send\") {\n        conn.recvPc.addIceCandidate(ice.candidate);\n      } else if (ice.direction === \"recv\") {\n        conn.sendPc.addIceCandidate(ice.candidate);\n      }\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIce(conn, (payload as { ICE?: unknown }).ICE);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"send\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"recv\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      receiveTrack(\n        mType,\n        setupTrackStopOnLongMute(event.track, conn.recvPc),\n        info\n      );\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    showConnectedStatus();\n  };\n\n  const initIpfs = async () => {\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n    const ipfs: IpfsType = await Ipfs.create({\n      repo: secureRandomId(),\n      config: {\n        Addresses: {\n          Swarm: [\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          ],\n        },\n      },\n    });\n    myPeerId = (await ipfs.id()).id;\n    myIpfsPubSubRoom = new IpfsPubSubRoom(ipfs, roomTopic);\n    myIpfsPubSubRoom.on(\"message\", pubsubHandler);\n    myIpfsPubSubRoom.on(\"peer joined\", () => {\n      broadcastData(null);\n    });\n    myIpfsPubSubRoom.on(\"peer left\", (peerId: string) => {\n      const conn = connMap.getConn(peerId);\n      if (conn) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    myIpfsPubSubRoom.on(\"subscribed\", () => {\n      broadcastData(null);\n    });\n    myIpfs = ipfs;\n    if (process.env.NODE_ENV !== \"production\") {\n      (window as any).myIpfs = myIpfs;\n    }\n  };\n  initIpfs();\n\n  const closeIpfs = async (ipfs: IpfsType, ipfsPubSubRoom: IpfsPubSubRoom) => {\n    await ipfsPubSubRoom.leave();\n    await ipfs.stop();\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective) {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    if (myIpfs) {\n      closeIpfs(myIpfs, myIpfsPubSubRoom as IpfsPubSubRoom);\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n"],"sourceRoot":""}