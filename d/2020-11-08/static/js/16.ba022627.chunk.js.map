{"version":3,"sources":["hooks/useSpatialArea.ts","components/SpatialArea.tsx"],"names":["isAvatarData","x","obj","position","e","isAreaData","isObject","Object","values","every","isAvatarMap","avatarMap","updatedAt","useSpatialArea","roomId","userId","useState","setAvatarMap","myAvatar","setMyAvatar","lastAreaDataRef","useRef","useEffect","current","Date","now","broadcastData","useBroadcastData","dataToBroadcast","data","spatialArea","areaData","setTimeout","undefined","useRoomData","useCallback","nextAvatarMap","prev","prevKeys","keys","nextKeys","length","key","a","b","Avatar","React","memo","nickname","faceStream","setPosition","useThree","size","viewport","aspect","width","firstPosition","bind","useDrag","first","initial","ix","iy","xy","y","fx","fy","texture","setTexture","videoTrack","getVideoTracks","canvas","document","createElement","canvasTexture","THREE","imageCapture","ImageCapture","ctx","getContext","timer","setInterval","grabFrame","bitmap","height","drawImage","font","textBaseline","fillStyle","fillText","needsUpdate","clearInterval","map","getInitialPosition","uid","parseInt","slice","SpatialCanvas","nicknameMap","faceStreamMap","getPosition","fallback","nextPosition","SpatialArea","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","className","value","onChange","target","videoDevice","deviceId","label","audioDevice"],"mappings":"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","file":"static/js/16.ba022627.chunk.js","sourcesContent":["import { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nexport type AvatarData = {\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.position[0] !== \"number\" ||\n      typeof obj.position[1] !== \"number\" ||\n      typeof obj.position[2] !== \"number\"\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isEqualAvatarData = (a: AvatarData, b?: AvatarData) =>\n  b &&\n  a.position[0] === b.position[0] &&\n  a.position[1] === b.position[1] &&\n  a.position[2] === b.position[2];\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\nconst isAvatarMap = (x: unknown): x is AvatarMap =>\n  isObject(x) && Object.values(x).every(isAvatarData);\n\ntype AreaData = {\n  avatarMap: AvatarMap;\n  updatedAt: number; // in millisecond\n};\n\nconst isAreaData = (x: unknown): x is AreaData =>\n  isObject(x) &&\n  isAvatarMap(x.avatarMap) &&\n  typeof (x as { updatedAt: unknown }).updatedAt === \"number\";\n\ntype SpatialAreaData =\n  | {\n      spatialArea: \"init\";\n    }\n  | {\n      spatialArea: \"sync\";\n      areaData: AreaData;\n    };\n\nconst isSpatialAreaData = (x: unknown): x is SpatialAreaData =>\n  isObject(x) &&\n  ((x as { spatialArea: unknown }).spatialArea === \"init\" ||\n    ((x as { spatialArea: unknown }).spatialArea === \"sync\" &&\n      isAreaData((x as { areaData: unknown }).areaData)));\n\nexport const useSpatialArea = (roomId: string, userId: string) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const [myAvatar, setMyAvatar] = useState<AvatarData>();\n  const lastAreaDataRef = useRef<AreaData>();\n  useEffect(() => {\n    lastAreaDataRef.current = {\n      avatarMap: {\n        ...avatarMap,\n        ...(myAvatar && { [userId]: myAvatar }),\n      },\n      updatedAt: Date.now(),\n    };\n  }, [userId, avatarMap, myAvatar]);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const dataToBroadcast = useRef<SpatialAreaData>();\n  useEffect(() => {\n    if (!lastAreaDataRef.current) return;\n    const data: SpatialAreaData = {\n      spatialArea: \"sync\",\n      areaData: lastAreaDataRef.current,\n    };\n    if (dataToBroadcast.current) {\n      dataToBroadcast.current = data;\n    } else {\n      dataToBroadcast.current = data;\n      setTimeout(() => {\n        broadcastData(data);\n        dataToBroadcast.current = undefined;\n      }, 200);\n    }\n  }, [broadcastData, userId, myAvatar]);\n\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isSpatialAreaData(data)) return;\n        if (data.spatialArea === \"init\") {\n          if (lastAreaDataRef.current) {\n            // TODO we don't need to broadcastData but sendData is enough\n            broadcastData({\n              spatialArea: \"sync\",\n              areaData: lastAreaDataRef.current,\n            });\n          }\n          return;\n        }\n        // FIXME why do we need this type assertion?\n        const { areaData } = data as { areaData: AreaData };\n        if (areaData.updatedAt < Date.now() - 1000) {\n          return;\n        }\n        const { [userId]: removed, ...nextAvatarMap } = areaData.avatarMap;\n        setAvatarMap((prev) => {\n          const prevKeys = Object.keys(prev);\n          const nextKeys = Object.keys(nextAvatarMap);\n          if (\n            prevKeys.length === nextKeys.length &&\n            prevKeys.every((key) =>\n              isEqualAvatarData(prev[key], nextAvatarMap[key])\n            )\n          ) {\n            // bail out\n            return prev;\n          }\n          return {\n            ...prev,\n            ...nextAvatarMap,\n          };\n        });\n      },\n      [userId, broadcastData]\n    )\n  );\n\n  useEffect(() => {\n    broadcastData({\n      spatialArea: \"init\",\n    });\n  }, [broadcastData]);\n\n  return {\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  };\n};\n","/* eslint react/jsx-props-no-spreading: off */\n\nimport React, { Suspense, useRef, useState, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarData, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  position: [number, number, number];\n  setPosition?: (nextPosition: [number, number, number]) => void;\n}>(({ nickname, faceStream, position, setPosition }) => {\n  const { size, viewport } = useThree();\n  const aspect = size.width / viewport.width;\n  const firstPosition = useRef<[number, number, number]>();\n  const bind = useDrag(({ first, initial: [ix, iy], xy: [x, y] }) => {\n    if (first) {\n      firstPosition.current = position;\n    }\n    const [fx, fy] = firstPosition.current as [number, number, number];\n    if (setPosition) {\n      setPosition([fx + (x - ix) / aspect, fy - (y - iy) / aspect, 0]);\n    }\n  });\n  const [texture, setTexture] = useState<THREE.CanvasTexture>();\n  useEffect(() => {\n    const videoTrack = faceStream?.getVideoTracks()[0];\n    if (!videoTrack) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const canvasTexture = new THREE.CanvasTexture(canvas);\n    setTexture(canvasTexture);\n    const imageCapture = new ImageCapture(videoTrack);\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    const timer = setInterval(async () => {\n      try {\n        const bitmap = await imageCapture.grabFrame();\n        canvas.width = bitmap.width;\n        canvas.height = bitmap.height;\n        ctx.drawImage(bitmap, 0, 0);\n        ctx.font = \"18px selif\";\n        ctx.textBaseline = \"top\";\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(nickname, 2, 2);\n        canvasTexture.needsUpdate = true;\n      } catch (e) {\n        // ignore\n      }\n    }, 1000 / 7.5);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [nickname, faceStream]);\n  if (!texture) return null;\n  return (\n    <sprite {...(setPosition && bind())} position={position}>\n      <spriteMaterial map={texture} />\n    </sprite>\n  );\n});\n\nconst getInitialPosition = (uid: string): [number, number, number] => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  myAvatar?: AvatarData;\n  setMyAvatar: (avatarData: AvatarData) => void;\n}>(\n  ({\n    userId,\n    nickname,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  }) => {\n    const getPosition = (uid: string) =>\n      avatarMap[uid]?.position || getInitialPosition(uid);\n\n    const setMyPosition = (nextPosition: [number, number, number]) => {\n      setMyAvatar({ position: nextPosition });\n    };\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map(\n            (uid) =>\n              uid !== userId && (\n                <Avatar\n                  key={uid}\n                  nickname={nicknameMap[uid] || \"\"}\n                  faceStream={faceStreamMap[uid] || null}\n                  position={getPosition(uid)}\n                />\n              )\n          )}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            position={myAvatar?.position || getInitialPosition(userId)}\n            setPosition={setMyPosition}\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, myAvatar, setMyAvatar } = useSpatialArea(roomId, userId);\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          myAvatar={myAvatar}\n          setMyAvatar={setMyAvatar}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n"],"sourceRoot":""}