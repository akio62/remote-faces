{"version":3,"sources":["hooks/useSpatialArea.ts","components/SpatialArea.tsx"],"names":["isAvatarData","x","obj","position","e","isAreaData","isObject","Object","values","every","isAvatarMap","avatarMap","updatedAt","useSpatialArea","roomId","userId","useState","setAvatarMap","lastAreaDataRef","useRef","broadcastData","useBroadcastData","dataToBroadcast","setAvatar","useCallback","uid","avatarData","nextAvatarMap","current","Date","now","data","spatialArea","areaData","setTimeout","undefined","useRoomData","prev","prevKeys","keys","nextKeys","length","key","a","b","useEffect","Avatar","React","memo","nickname","faceStream","setPosition","useThree","size","viewport","aspect","width","firstPosition","bind","useDrag","first","initial","ix","iy","xy","y","fx","fy","texture","setTexture","videoTrack","getVideoTracks","canvas","document","createElement","canvasTexture","THREE","imageCapture","ImageCapture","ctx","getContext","timer","setInterval","grabFrame","bitmap","height","drawImage","font","textBaseline","fillStyle","fillText","needsUpdate","clearInterval","map","SpatialCanvas","nicknameMap","faceStreamMap","getPosition","parseInt","slice","getInitialPosition","nextPosition","fallback","SpatialArea","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","className","value","onChange","target","videoDevice","deviceId","label","audioDevice"],"mappings":"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","file":"static/js/16.431e5b5d.chunk.js","sourcesContent":["import { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nexport type AvatarData = {\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.position[0] !== \"number\" ||\n      typeof obj.position[1] !== \"number\" ||\n      typeof obj.position[2] !== \"number\"\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isEqualAvatarData = (a: AvatarData, b: AvatarData) =>\n  a.position[0] === b.position[0] &&\n  a.position[1] === b.position[1] &&\n  a.position[2] === b.position[2];\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\nconst isAvatarMap = (x: unknown): x is AvatarMap =>\n  isObject(x) && Object.values(x).every(isAvatarData);\n\ntype AreaData = {\n  avatarMap: AvatarMap;\n  updatedAt: number; // in millisecond\n};\n\nconst isAreaData = (x: unknown): x is AreaData =>\n  isObject(x) &&\n  isAvatarMap(x.avatarMap) &&\n  typeof (x as { updatedAt: unknown }).updatedAt === \"number\";\n\ntype SpatialAreaData =\n  | {\n      spatialArea: \"init\";\n    }\n  | {\n      spatialArea: \"sync\";\n      areaData: AreaData;\n    };\n\nconst isSpatialAreaData = (x: unknown): x is SpatialAreaData =>\n  isObject(x) &&\n  ((x as { spatialArea: unknown }).spatialArea === \"init\" ||\n    ((x as { spatialArea: unknown }).spatialArea === \"sync\" &&\n      isAreaData((x as { areaData: unknown }).areaData)));\n\nexport const useSpatialArea = (roomId: string, userId: string) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const lastAreaDataRef = useRef<AreaData>();\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const dataToBroadcast = useRef<SpatialAreaData>();\n  const setAvatar = useCallback(\n    (uid: string, avatarData: AvatarData) => {\n      const nextAvatarMap = {\n        ...lastAreaDataRef.current?.avatarMap,\n        [uid]: avatarData,\n      };\n      setAvatarMap(nextAvatarMap);\n      lastAreaDataRef.current = {\n        avatarMap: nextAvatarMap,\n        updatedAt: Date.now(),\n      };\n      const data: SpatialAreaData = {\n        spatialArea: \"sync\",\n        areaData: lastAreaDataRef.current,\n      };\n      if (dataToBroadcast.current) {\n        dataToBroadcast.current = data;\n      } else {\n        dataToBroadcast.current = data;\n        setTimeout(() => {\n          broadcastData(data);\n          dataToBroadcast.current = undefined;\n        }, 200);\n      }\n    },\n    [broadcastData]\n  );\n\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isSpatialAreaData(data)) return;\n        if (data.spatialArea === \"init\") {\n          if (lastAreaDataRef.current) {\n            // TODO we don't need to broadcastData but sendData is enough\n            broadcastData({\n              spatialArea: \"sync\",\n              areaData: lastAreaDataRef.current,\n            });\n          }\n          return;\n        }\n        // FIXME why do we need this type assertion?\n        const { areaData } = data as { areaData: AreaData };\n        if (\n          lastAreaDataRef.current &&\n          lastAreaDataRef.current.updatedAt > areaData.updatedAt\n        ) {\n          return;\n        }\n        setAvatarMap((prev) => {\n          const prevKeys = Object.keys(prev);\n          const nextKeys = Object.keys(areaData.avatarMap);\n          if (\n            prevKeys.length === nextKeys.length &&\n            prevKeys.every((key) =>\n              isEqualAvatarData(prev[key], areaData.avatarMap[key])\n            )\n          ) {\n            // bail out\n            return prev;\n          }\n          return {\n            ...prev,\n            ...areaData.avatarMap,\n          };\n        });\n      },\n      [broadcastData]\n    )\n  );\n\n  useEffect(() => {\n    broadcastData({\n      spatialArea: \"init\",\n    });\n  }, [broadcastData]);\n\n  return {\n    avatarMap,\n    setAvatar,\n  };\n};\n","/* eslint react/jsx-props-no-spreading: off */\n\nimport React, { Suspense, useRef, useState, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarData, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  position: [number, number, number];\n  setPosition: (nextPosition: [number, number, number]) => void;\n}>(({ nickname, faceStream, position, setPosition }) => {\n  const { size, viewport } = useThree();\n  const aspect = size.width / viewport.width;\n  const firstPosition = useRef<[number, number, number]>();\n  const bind = useDrag(({ first, initial: [ix, iy], xy: [x, y] }) => {\n    if (first) {\n      firstPosition.current = position;\n    }\n    const [fx, fy] = firstPosition.current as [number, number, number];\n    setPosition([fx + (x - ix) / aspect, fy - (y - iy) / aspect, 0]);\n  });\n  const [texture, setTexture] = useState<THREE.CanvasTexture>();\n  useEffect(() => {\n    const videoTrack = faceStream?.getVideoTracks()[0];\n    if (!videoTrack) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const canvasTexture = new THREE.CanvasTexture(canvas);\n    setTexture(canvasTexture);\n    const imageCapture = new ImageCapture(videoTrack);\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    const timer = setInterval(async () => {\n      try {\n        const bitmap = await imageCapture.grabFrame();\n        canvas.width = bitmap.width;\n        canvas.height = bitmap.height;\n        ctx.drawImage(bitmap, 0, 0);\n        ctx.font = \"18px selif\";\n        ctx.textBaseline = \"top\";\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(nickname, 2, 2);\n        canvasTexture.needsUpdate = true;\n      } catch (e) {\n        // ignore\n      }\n    }, 1000 / 7.5);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [nickname, faceStream]);\n  if (!texture) return null;\n  return (\n    <sprite {...bind()} position={position}>\n      <spriteMaterial map={texture} />\n    </sprite>\n  );\n});\n\nconst getInitialPosition = (uid: string) => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  setAvatar: (uid: string, avatarData: AvatarData) => void;\n}>(\n  ({\n    userId,\n    nickname,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    setAvatar,\n  }) => {\n    const getPosition = (uid: string) =>\n      avatarMap[uid]?.position || getInitialPosition(uid);\n\n    const setPosition = (uid: string) => (\n      nextPosition: [number, number, number]\n    ) => {\n      setAvatar(uid, { position: nextPosition });\n    };\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map(\n            (uid) =>\n              uid !== userId && (\n                <Avatar\n                  key={uid}\n                  nickname={nicknameMap[uid] || \"\"}\n                  faceStream={faceStreamMap[uid] || null}\n                  position={getPosition(uid)}\n                  setPosition={setPosition(uid)}\n                />\n              )\n          )}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            position={getPosition(userId)}\n            setPosition={setPosition(userId)}\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, setAvatar } = useSpatialArea(roomId, userId);\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          setAvatar={setAvatar}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n"],"sourceRoot":""}