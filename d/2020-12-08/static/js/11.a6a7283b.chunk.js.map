{"version":3,"sources":["hooks/useSpatialArea.ts","components/SpatialArea.tsx","network/trackUtils.ts"],"names":["useSpatialArea","roomId","userId","useState","avatarMap","setAvatarMap","myAvatar","setMyAvatar","lastMyAvatarRef","useRef","useEffect","current","broadcastData","useBroadcastData","dataToBroadcast","data","spatialArea","avatarData","setTimeout","undefined","useRoomData","useCallback","x","isObject","obj","position","e","isAvatarData","uid","prev","Avatar","React","memo","nickname","faceStream","setPosition","distance","muted","useThree","size","viewport","aspect","width","firstPosition","bind","useDrag","first","initial","ix","iy","xy","y","fx","fy","texture","setTexture","videoTrack","getVideoTracks","isMyself","gainValueRef","canvas","document","createElement","canvasTexture","THREE","imageCapture","ImageCapture","ctx","getContext","timer","setInterval","a","grabFrame","bitmap","height","drawImage","font","textBaseline","fillStyle","fillText","toFixed","needsUpdate","clearInterval","audioTrack","getAudioTracks","setGainRef","audioCtx","AudioContext","destination","createMediaStreamDestination","source","createMediaStreamSource","MediaStream","gainNode","createGain","gain","value","setValueAtTime","currentTime","connect","gainedAudioTrack","stream","videoEle","autoplay","body","appendChild","loopbackPeerConnection","srcObject","close","dispatchEvent","Event","removeChild","Math","min","max","map","getInitialPosition","parseInt","slice","SpatialCanvas","nicknameMap","faceStreamMap","getPosition","myPosition","fallback","Object","keys","hypot","key","nextPosition","SpatialArea","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","audioDevices","useAudioDevices","audioDeviceId","setAudioDeviceId","useFaceVideos","useNicknameMap","className","onChange","target","videoDevice","deviceId","label","audioDevice","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","sleep","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","addEventListener","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","getImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","setImage","dataURL"],"mappings":"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","file":"static/js/11.a6a7283b.chunk.js","sourcesContent":["import { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nexport type AvatarData = {\n  position: [number, number, number];\n};\n\nconst isAvatarData = (x: unknown): x is AvatarData => {\n  try {\n    const obj = x as AvatarData;\n    if (\n      typeof obj.position[0] !== \"number\" ||\n      typeof obj.position[1] !== \"number\" ||\n      typeof obj.position[2] !== \"number\"\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport type AvatarMap = {\n  [userId: string]: AvatarData;\n};\n\ntype SpatialAreaData =\n  | {\n      spatialArea: \"init\";\n    }\n  | {\n      spatialArea: \"avatar\";\n      userId: string;\n      avatarData: AvatarData;\n    };\n\nconst isSpatialAreaData = (x: unknown): x is SpatialAreaData =>\n  isObject(x) &&\n  ((x as { spatialArea: unknown }).spatialArea === \"init\" ||\n    ((x as { spatialArea: unknown }).spatialArea === \"avatar\" &&\n      isAvatarData((x as { avatarData: unknown }).avatarData)));\n\nexport const useSpatialArea = (roomId: string, userId: string) => {\n  const [avatarMap, setAvatarMap] = useState<AvatarMap>({});\n  const [myAvatar, setMyAvatar] = useState<AvatarData>();\n  const lastMyAvatarRef = useRef<AvatarData>();\n  useEffect(() => {\n    lastMyAvatarRef.current = myAvatar;\n  }, [myAvatar]);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const dataToBroadcast = useRef<SpatialAreaData>();\n  useEffect(() => {\n    if (!myAvatar) return;\n    const data: SpatialAreaData = {\n      spatialArea: \"avatar\",\n      userId,\n      avatarData: myAvatar,\n    };\n    if (dataToBroadcast.current) {\n      dataToBroadcast.current = data;\n    } else {\n      dataToBroadcast.current = data;\n      setTimeout(() => {\n        broadcastData(dataToBroadcast.current);\n        dataToBroadcast.current = undefined;\n      }, 200);\n    }\n  }, [broadcastData, userId, myAvatar]);\n\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isSpatialAreaData(data)) return;\n        if (data.spatialArea === \"init\") {\n          if (lastMyAvatarRef.current) {\n            // TODO we don't need to broadcastData but sendData is enough\n            broadcastData({\n              spatialArea: \"avatar\",\n              avatarData: lastMyAvatarRef.current,\n            });\n          }\n        } else if (data.spatialArea === \"avatar\") {\n          const uid = (data as { userId: string }).userId;\n          const { avatarData } = data as { avatarData: AvatarData };\n          setAvatarMap((prev) => ({\n            ...prev,\n            [uid]: avatarData,\n          }));\n        }\n      },\n      [broadcastData]\n    )\n  );\n\n  useEffect(() => {\n    broadcastData({\n      spatialArea: \"init\",\n    });\n  }, [broadcastData]);\n\n  return {\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  };\n};\n","/* eslint react/jsx-props-no-spreading: off */\n\nimport React, { Suspense, useRef, useState, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { useDrag } from \"react-use-gesture\";\n\nimport \"./SpatialArea.css\";\nimport { useSpatialArea, AvatarData, AvatarMap } from \"../hooks/useSpatialArea\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { loopbackPeerConnection } from \"../network/trackUtils\";\n\nconst Avatar = React.memo<{\n  nickname: string;\n  faceStream: MediaStream | null;\n  position: [number, number, number];\n  setPosition?: (nextPosition: [number, number, number]) => void;\n  distance?: number;\n  muted?: boolean;\n}>(({ nickname, faceStream, position, setPosition, distance, muted }) => {\n  const { size, viewport } = useThree();\n  const aspect = size.width / viewport.width;\n  const firstPosition = useRef<[number, number, number]>();\n  const bind = useDrag(({ first, initial: [ix, iy], xy: [x, y] }) => {\n    if (first) {\n      firstPosition.current = position;\n    }\n    const [fx, fy] = firstPosition.current as [number, number, number];\n    if (setPosition) {\n      setPosition([fx + (x - ix) / aspect, fy - (y - iy) / aspect, 0]);\n    }\n  });\n  const [texture, setTexture] = useState<THREE.CanvasTexture>();\n  const videoTrack = faceStream?.getVideoTracks()[0];\n  const isMyself = !!setPosition;\n  const gainValueRef = useRef(0.5);\n  useEffect(() => {\n    if (!videoTrack) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const canvasTexture = new THREE.CanvasTexture(canvas);\n    setTexture(canvasTexture);\n    const imageCapture = new ImageCapture(videoTrack);\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    const timer = setInterval(async () => {\n      try {\n        const bitmap = await imageCapture.grabFrame();\n        canvas.width = bitmap.width;\n        canvas.height = bitmap.height;\n        ctx.drawImage(bitmap, 0, 0);\n        ctx.font = \"18px selif\";\n        ctx.textBaseline = \"top\";\n        ctx.fillStyle = \"blue\";\n        ctx.fillText(nickname, 2, 2);\n        if (!isMyself) {\n          ctx.fillStyle = \"red\";\n          ctx.fillText(gainValueRef.current.toFixed(2), 2, 54);\n        }\n        canvasTexture.needsUpdate = true;\n      } catch (e) {\n        // ignore\n      }\n    }, 1000 / 7.5);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [nickname, isMyself, videoTrack]);\n  const audioTrack = !isMyself && faceStream?.getAudioTracks()[0];\n  const setGainRef = useRef<(value: number) => void>();\n  useEffect(() => {\n    if (!audioTrack) return undefined;\n    const audioCtx = new AudioContext();\n    const destination = audioCtx.createMediaStreamDestination();\n    const source = audioCtx.createMediaStreamSource(\n      new MediaStream([audioTrack])\n    );\n    const gainNode = audioCtx.createGain();\n    gainNode.gain.value = 0.5;\n    setGainRef.current = (value: number) => {\n      gainNode.gain.setValueAtTime(value, audioCtx.currentTime);\n      gainValueRef.current = value;\n    };\n    source.connect(gainNode);\n    gainNode.connect(destination);\n    const gainedAudioTrack = destination.stream.getAudioTracks()[0];\n    const videoEle = document.createElement(\"video\");\n    videoEle.autoplay = true;\n    document.body.appendChild(videoEle);\n    (async () => {\n      videoEle.srcObject = new MediaStream([\n        await loopbackPeerConnection(gainedAudioTrack),\n      ]);\n    })();\n    return () => {\n      audioCtx.close();\n      gainedAudioTrack.dispatchEvent(new Event(\"ended\"));\n      document.body.removeChild(videoEle);\n    };\n  }, [audioTrack]);\n  useEffect(() => {\n    if (!setGainRef.current) return;\n    if (distance === undefined || muted) {\n      setGainRef.current(0.0);\n      return;\n    }\n    setGainRef.current(Math.min(1.0, Math.max(0.0, (5 - distance) / 5)));\n  }, [muted, distance]);\n  if (!texture) return null;\n  return (\n    <sprite {...(setPosition && bind())} position={position}>\n      <spriteMaterial map={texture} />\n    </sprite>\n  );\n});\n\nconst getInitialPosition = (uid: string): [number, number, number] => [\n  parseInt(uid.slice(0, 2), 16) / 128 - 1,\n  parseInt(uid.slice(2, 4), 16) / 128 - 1,\n  0,\n];\n\nconst SpatialCanvas = React.memo<{\n  userId: string;\n  nickname: string;\n  faceStream: MediaStream | null;\n  nicknameMap: { [userId: string]: string };\n  faceStreamMap: { [userId: string]: MediaStream };\n  avatarMap: AvatarMap;\n  myAvatar?: AvatarData;\n  setMyAvatar: (avatarData: AvatarData) => void;\n}>(\n  ({\n    userId,\n    nickname,\n    faceStream,\n    nicknameMap,\n    faceStreamMap,\n    avatarMap,\n    myAvatar,\n    setMyAvatar,\n  }) => {\n    const getPosition = (uid: string) =>\n      avatarMap[uid]?.position || getInitialPosition(uid);\n\n    const setMyPosition = (nextPosition: [number, number, number]) => {\n      setMyAvatar({ position: nextPosition });\n    };\n    const myPosition = myAvatar?.position || getInitialPosition(userId);\n\n    return (\n      <Canvas>\n        <Suspense fallback={null}>\n          <ambientLight />\n          {Object.keys(faceStreamMap).map((uid) => {\n            if (uid === userId) return null;\n            const position = getPosition(uid);\n            const distance = Math.hypot(\n              position[0] - myPosition[0],\n              position[1] - myPosition[1],\n              position[2] - myPosition[2]\n            );\n            return (\n              <Avatar\n                key={uid}\n                nickname={nicknameMap[uid] || \"\"}\n                faceStream={faceStreamMap[uid] || null}\n                position={getPosition(uid)}\n                distance={distance}\n              />\n            );\n          })}\n          <Avatar\n            nickname={nickname}\n            faceStream={faceStream}\n            position={myPosition}\n            setPosition={setMyPosition}\n            muted\n          />\n        </Suspense>\n      </Canvas>\n    );\n  }\n);\n\nexport const SpatialArea = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const audioDevices = useAudioDevices();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>(\"\");\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    !!videoDeviceId,\n    !!audioDeviceId,\n    !!audioDeviceId,\n    videoDeviceId,\n    audioDeviceId,\n    \"spatialArea\"\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const { avatarMap, myAvatar, setMyAvatar } = useSpatialArea(roomId, userId);\n\n  return (\n    <div className=\"SpatialArea-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          <option value=\"\">None</option>\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div>\n        Select Mic:{\" \"}\n        <select\n          value={audioDeviceId}\n          onChange={(e) => {\n            setAudioDeviceId(e.target.value);\n          }}\n        >\n          <option value=\"\">None</option>\n          {audioDevices.map((audioDevice) => (\n            <option key={audioDevice.deviceId} value={audioDevice.deviceId}>\n              {audioDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"SpatialArea-body\">\n        <SpatialCanvas\n          userId={userId}\n          nickname={nickname}\n          faceStream={faceStream}\n          nicknameMap={nicknameMap}\n          faceStreamMap={faceStreamMap}\n          avatarMap={avatarMap}\n          myAvatar={myAvatar}\n          setMyAvatar={setMyAvatar}\n        />\n      </div>\n    </div>\n  );\n});\n\nexport default SpatialArea;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n"],"sourceRoot":""}