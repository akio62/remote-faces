{"version":3,"sources":["utils/sleep.ts","network/trackUtils.ts","network/pubsubUtils.ts","network/pubsubRoom.ts","utils/types.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","peerIndexCounter","createConnectionMap","map","Map","setAcceptingMediaTypes","conn","mediaTypes","value","get","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","peerIndex","audioWorkers","vidoeSetImages","getConn","findConn","Array","from","values","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","topicsForMediaTypes","getTopicForMediaType","roomId","mediaType","key","topic","sha256","slice","ROOM_ID_PREFIX_LEN","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","roomTopic","importCryptoKey","cryptoKey","type","Ipfs","create","repo","secureRandomId","config","Addresses","Swarm","myIpfs","id","myPeerId","pubsub","subscribe","msg","pubsubHandler","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","encryptStringToChunks","stringify","publish","error","sendPayloadDirectly","broadcastData","data","sendData","mediaTypeDisposeMap","acceptAudioMedia","disposeList","audioHandler","warn","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","e","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","push","terminate","decryptBufferToChunks","byteOffset","byteLength","bufList","buf","postMessage","unshift","unsubscribe","acceptVideoMedia","videoHandler","acceptMediaTypes","mTypes","existingMediaType","includes","dispose","endsWith","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","x","handlePayloadData","handlePayload","isObject","initConnection","payloadUserId","getUserIdFromPayload","peerIndexList","checkPeers","peers","length","trackDisposeMap","runDispose","addAudioTrack","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","encryptBufferFromChunks","splice","addVideoTrack","videoDisposed","loop","mediaTypeMap","removeTrack","hasStringProp","prop","hasObjectProp"],"mappings":"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","file":"static/js/7.a558a454.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","import Ipfs, { PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await Ipfs.create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 40) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, encrypted);\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, encrypted);\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n"],"sourceRoot":""}