{"version":3,"sources":["hooks/useVideoShare.ts","components/VideoShare.tsx","hooks/useNicknameMap.ts"],"names":["videoType","Video","React","memo","nickname","stream","videoRef","useRef","useEffect","current","srcObject","className","ref","autoPlay","muted","VideoShare","roomId","userId","videoDevices","useVideoDevices","useState","videoDeviceId","setVideoDeviceId","enabled","setEnabled","videoStream","setVideoStream","videoStreamMap","setVideoStreamMap","cleanupFns","forEach","fn","trackMap","useSnapshot","getRoomState","Object","entries","uid","track","readyState","getTracks","includes","prev","MediaStream","onended","addEventListener","push","removeEventListener","roomState","addMediaType","removeMediaType","cleanup","a","getVideoStream","result","getVideoTracks","addTrack","dispose","removeTrack","useVideoShare","nicknameMap","useNicknameMap","numOfVideos","values","filter","x","length","value","onChange","e","target","map","videoDevice","deviceId","label","type","onClick","style","gridTemplateColumns","Math","ceil","sqrt","keys","screenUserId","setNicknameMap","ydoc","getMap","listener","copied","changed","data","isObject","info","observe","unobserve"],"mappings":"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","file":"static/js/21.43e76392.chunk.js","sourcesContent":["import { useEffect, useState, useRef } from \"react\";\nimport { useSnapshot } from \"valtio\";\n\nimport { getVideoStream } from \"../media/video\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst videoType = \"cameraVideo\";\n\nexport const useVideoShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void,\n  videoDeviceId?: string\n) => {\n  const [videoStream, setVideoStream] = useState<MediaStream | null>(null);\n  const [videoStreamMap, setVideoStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = ([uid, track]: [string, MediaStreamTrack]) => {\n    if (track.readyState === \"ended\") return;\n    if (videoStreamMap[uid]?.getTracks().includes(track)) return;\n    setVideoStreamMap((prev) => ({\n      ...prev,\n      [uid]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setVideoStreamMap((prev) => ({\n        ...prev,\n        [uid]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  };\n\n  const trackMap = useSnapshot(getRoomState(roomId, userId).trackMap);\n  Object.entries(trackMap[videoType] || {}).forEach(onTrack);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    roomState.addMediaType(videoType);\n    return () => {\n      roomState.removeMediaType(videoType);\n    };\n  }, [roomId, userId]);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    let cleanup: (() => void) | null | false = null;\n    if (enabled) {\n      (async () => {\n        const result = await getVideoStream(videoDeviceId);\n        const [track] = result.stream.getVideoTracks();\n        roomState.addTrack(videoType, track);\n        setVideoStream(result.stream);\n        track.addEventListener(\"ended\", () => {\n          if (cleanup) cleanup();\n          cleanup = null;\n        });\n        const dispose = () => {\n          roomState.removeTrack(videoType);\n          result.dispose();\n          setVideoStream(null);\n          setEnabled(false);\n        };\n        if (cleanup === false) {\n          dispose();\n        } else {\n          cleanup = dispose;\n        }\n      })();\n    }\n    return () => {\n      if (cleanup) cleanup();\n      cleanup = false;\n    };\n  }, [roomId, userId, videoDeviceId, enabled, setEnabled]);\n\n  return { videoStream, videoStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./VideoShare.css\";\nimport { useVideoShare } from \"../hooks/useVideoShare\";\nimport { useVideoDevices } from \"../hooks/useAvailableDevices\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Video = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"VideoShare-nickname\">{nickname}</div>\n      <video className=\"VideoShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\nexport const VideoShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>();\n  const [enabled, setEnabled] = useState(false);\n  const { videoStream, videoStreamMap } = useVideoShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled,\n    videoDeviceId\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const numOfVideos =\n    (videoStream ? 1 : 0) +\n    Object.values(videoStreamMap).filter((x) => x).length;\n\n  return (\n    <div className=\"VideoShare-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop video share\" : \"Start video share\"}\n      </button>\n      <div\n        className=\"VideoShare-body\"\n        style={{\n          gridTemplateColumns: `repeat(${Math.ceil(\n            Math.sqrt(numOfVideos)\n          )}, 1fr)`,\n        }}\n      >\n        {videoStream && <Video nickname={nickname} stream={videoStream} />}\n        {Object.keys(videoStreamMap).map((screenUserId) => {\n          const stream = videoStreamMap[screenUserId];\n          if (!stream) return null;\n          return (\n            <Video\n              key={screenUserId}\n              nickname={nicknameMap[screenUserId] || \"No Name\"}\n              stream={stream}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n\nexport default VideoShare;\n","import { useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\ntype NicknameMap = {\n  [userId: string]: string;\n};\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<NicknameMap>({});\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    const map = roomState.ydoc.getMap(\"faceImages\");\n    const listener = () => {\n      setNicknameMap((prev) => {\n        const copied = { ...prev };\n        let changed = false;\n        map.forEach((data, uid) => {\n          if (uid === userId) return;\n          if (!hasInfoNickname(data)) return;\n          if (!copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          } else if (data.info.nickname !== copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          }\n        });\n        if (changed) {\n          return copied;\n        }\n        return prev;\n      });\n    };\n    map.observe(listener);\n    listener();\n    return () => {\n      map.unobserve(listener);\n    };\n  }, [roomId, userId]);\n\n  return nicknameMap;\n};\n"],"sourceRoot":""}