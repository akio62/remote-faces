{"version":3,"sources":["utils/sleep.ts","network/trackUtils.ts","network/ipfsUtils.ts","network/pubsubRoom.ts","utils/types.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","imageCapture","ImageCapture","canvas","document","createElement","ctx","getContext","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","createConnectionMap","map","Map","registerRemoteMediaTypeFromSDP","conn","msid2mediaType","sdpLines","mid","value","get","peer","split","forEach","line","startsWith","slice","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","peerIndex","sendPc","recvPc","getConn","findConn","Array","from","values","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEachConnsAcceptingMedia","includes","size","getRemoteMediaType","registerRemoteMediaType","sdp","hasObjectProp","hasStringProp","topicsForMediaTypes","getTopicForMediaType","roomId","key","topic","sha256","ROOM_ID_PREFIX_LEN","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myIpfs","myPeerId","connMap","roomTopic","importCryptoKey","cryptoKey","showConnectedStatus","peerIndexList","type","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","encryptStringToChunks","stringify","warn","pubsub","publish","error","sendPayloadDirectly","noop","subscribe","unsubscribe","broadcastData","data","sendData","faceAudioDisposeList","faceVideoDisposeList","acceptMediaTypes","mTypes","faceAudioHandler","msg","c","worker","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","Worker","onmessage","e","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","push","terminate","decryptBufferToChunks","byteOffset","byteLength","bufList","buf","postMessage","dispose","splice","faceVideoHandler","decryptString","filter","transceivers","getReceivers","mType","readyState","sendSDP","getMsid2MediaType","SDP","handlePayloadSDP","isObject","negotiationId","negotiationIdMap","startNegotiation","running","secureRandomId","negotiate","sendIce","ice","ICE","handlePayloadIce","direction","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","x","syncAllTracks","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","pubsubHandler","checkPeers","peers","lastInitIpfsTime","Date","now","prevIpfs","closeIpfs","initIpfs","Ipfs","create","repo","config","Addresses","Swarm","ipfs","id","trackDisposeMap","runDispose","mediaTypeMap","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","encryptBufferFromChunks","timer","setInterval","encryptString","clearInterval","name","removeTrack","item","sender","getSenders","s","senders","some","prop"],"mappings":"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","file":"static/js/7.16f6dfed.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const imageCapture = new ImageCapture(track);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nlet peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  const getRemoteMediaType = (conn: Connection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Connection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Connection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Ipfs, { IpfsType, PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptString,\n  decryptString,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { isObject, hasStringProp, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport {\n  setupTrackStopOnLongMute,\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myIpfs: IpfsType | null = null;\n  let myPeerId: string | null = null;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        if (!myIpfs) {\n          console.warn(\"no myIpfs initialized\");\n          return;\n        }\n        await myIpfs.pubsub.publish(topic, encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // HACK somehow, publish doesn't work without this\n    if (myIpfs) {\n      const noop = () => null;\n      await myIpfs.pubsub.subscribe(topic, noop);\n      await myIpfs.pubsub.unsubscribe(topic, noop);\n    }\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  // TODO very limited use case for now\n  const faceAudioDisposeList: (() => void)[] = [];\n  const faceVideoDisposeList: (() => void)[] = [];\n\n  const acceptMediaTypes = async (mTypes: string[]) => {\n    if (mTypes.includes(\"faceAudio\") && !faceAudioDisposeList.length) {\n      // XXX experimental\n      if (myIpfs) {\n        const topic = await getTopicForMediaType(roomId, \"faceAudio\");\n        const faceAudioHandler: PubsubHandler = async (msg) => {\n          if (msg.from === myPeerId) return;\n          const conn = connMap.getConn(msg.from);\n          if (!conn) {\n            console.warn(\"conn not ready\");\n            return;\n          }\n          const info: PeerInfo = {\n            userId: conn.userId,\n            peerIndex: conn.peerIndex,\n            mediaTypes: connMap.getAcceptingMediaTypes(conn),\n          };\n          const c: {\n            worker: Worker;\n          } = conn as any; // TODO do it more cleanly\n          if (!c.worker) {\n            const audioCtx = new AudioContext();\n            const destination = audioCtx.createMediaStreamDestination();\n            let currTime = 0;\n            let pending = 0;\n            const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n            worker.onmessage = (e) => {\n              const buffer = new Float32Array(e.data);\n              if (!pending) {\n                currTime = audioCtx.currentTime;\n              }\n              currTime += 0.06; // 60ms\n              pending += 1;\n              const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n              audioBuffer.copyToChannel(buffer, 0);\n              const audioBufferSource = audioCtx.createBufferSource();\n              audioBufferSource.buffer = audioBuffer;\n              audioBufferSource.connect(destination);\n              audioBufferSource.onended = () => {\n                pending -= 1;\n              };\n              audioBufferSource.start(currTime);\n            };\n            c.worker = worker;\n            const audioTrack = destination.stream.getAudioTracks()[0];\n            receiveTrack(\n              \"faceAudio\",\n              await loopbackPeerConnection(audioTrack),\n              info\n            );\n            faceAudioDisposeList.push(() => {\n              audioCtx.close();\n              audioTrack.dispatchEvent(new Event(\"ended\"));\n              worker.terminate();\n              if (c.worker === worker) {\n                delete c.worker;\n              }\n            });\n          }\n          const bufList = await decryptBufferToChunks(\n            msg.data.buffer,\n            msg.data.byteOffset,\n            msg.data.byteLength,\n            cryptoKey\n          );\n          if (c.worker) {\n            bufList.forEach((buf) => {\n              c.worker.postMessage([buf], [buf]);\n            });\n          }\n        };\n        myIpfs.pubsub.subscribe(topic, faceAudioHandler);\n        faceAudioDisposeList.push(() => {\n          if (myIpfs) {\n            myIpfs.pubsub.unsubscribe(topic, faceAudioHandler);\n          }\n        });\n      }\n    } else if (!mTypes.includes(\"faceAudio\") && faceAudioDisposeList.length) {\n      faceAudioDisposeList.forEach((dispose) => dispose());\n      faceAudioDisposeList.splice(0, faceAudioDisposeList.length);\n    }\n    if (mTypes.includes(\"faceVideo\") && !faceVideoDisposeList.length) {\n      // XXX experimental\n      if (myIpfs) {\n        const topic = await getTopicForMediaType(roomId, \"faceVideo\");\n        const faceVideoHandler: PubsubHandler = async (msg) => {\n          if (msg.from === myPeerId) return;\n          const conn = connMap.getConn(msg.from);\n          if (!conn) {\n            console.warn(\"conn not ready\");\n            return;\n          }\n          const info: PeerInfo = {\n            userId: conn.userId,\n            peerIndex: conn.peerIndex,\n            mediaTypes: connMap.getAcceptingMediaTypes(conn),\n          };\n          const c: {\n            setImage: (s: string) => void;\n          } = conn as any; // TODO do it more cleanly\n          if (!c.setImage) {\n            const { videoTrack, setImage } = imageToVideoTrackConverter();\n            c.setImage = setImage;\n            receiveTrack(\"faceVideo\", videoTrack, info);\n            faceVideoDisposeList.push(() => {\n              videoTrack.dispatchEvent(new Event(\"ended\"));\n            });\n          }\n          try {\n            const str = await decryptString(msg.data, cryptoKey);\n            const payload = JSON.parse(str);\n            if (hasStringProp(payload, \"dataURL\")) {\n              c.setImage(payload.dataURL);\n            }\n          } catch (e) {\n            console.info(\"Error in parse for face video\", e);\n          }\n        };\n        myIpfs.pubsub.subscribe(topic, faceVideoHandler);\n        faceVideoDisposeList.push(() => {\n          if (myIpfs) {\n            myIpfs.pubsub.unsubscribe(topic, faceVideoHandler);\n          }\n        });\n      }\n    } else if (!mTypes.includes(\"faceVideo\") && faceVideoDisposeList.length) {\n      faceVideoDisposeList.forEach((dispose) => dispose());\n      faceVideoDisposeList.splice(0, faceVideoDisposeList.length);\n    }\n    // eslint-disable-next-line no-param-reassign\n    mTypes = mTypes.filter((t) => t !== \"faceAudio\" && t !== \"faceVideo\");\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConns((conn) => {\n        const info: PeerInfo = {\n          userId: conn.userId,\n          peerIndex: conn.peerIndex,\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        const transceivers = conn.recvPc.getTransceivers();\n        conn.recvPc.getReceivers().forEach((receiver) => {\n          const transceiver = transceivers.find((t) => t.receiver === receiver);\n          const mid = transceiver?.mid;\n          const mType = mid && connMap.getRemoteMediaType(conn, mid);\n          if (!mType) {\n            console.warn(\"failed to find media type from mid\");\n            return;\n          }\n          if (\n            receiver.track.readyState === \"live\" &&\n            !mediaTypes.includes(mType) &&\n            mTypes.includes(mType)\n          ) {\n            receiveTrack(\n              mType,\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          }\n        });\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const sendSDP = async (\n    conn: Connection,\n    sdp:\n      | {\n          negotiationId: string;\n          offer: RTCSessionDescriptionInit;\n        }\n      | {\n          negotiationId: string;\n          answer: RTCSessionDescriptionInit;\n        }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    await sendPayloadDirectly(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (!hasStringProp(sdp, \"negotiationId\")) {\n      console.warn(\"negotiationId not found in SDP\");\n      return;\n    }\n    const { negotiationId } = sdp;\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.recvPc.setRemoteDescription(sdp.offer);\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { negotiationId, answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      if (negotiationIdMap.get(conn) === negotiationId) {\n        negotiationIdMap.delete(conn);\n      }\n      try {\n        await conn.sendPc.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const negotiationIdMap = new WeakMap<Connection, string>();\n  const startNegotiation = (conn: Connection) => {\n    const running = negotiationIdMap.has(conn);\n    negotiationIdMap.set(conn, secureRandomId());\n    if (running) return;\n    const negotiate = async () => {\n      const negotiationId = negotiationIdMap.get(conn);\n      if (!negotiationId) return;\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      await sendSDP(conn, { negotiationId, offer });\n      await sleep(5000);\n      negotiate();\n    };\n    negotiate();\n  };\n\n  const sendIce = (\n    conn: Connection,\n    ice: {\n      direction: \"send\" | \"recv\";\n      candidate: RTCIceCandidate;\n    }\n  ) => {\n    sendPayloadDirectly(conn, { ICE: ice });\n  };\n\n  const handlePayloadIce = (conn: Connection, ice: unknown) => {\n    if (!isObject(ice)) return;\n    if (!hasStringProp(ice, \"direction\")) {\n      console.warn(\"direction not found in ICE\");\n      return;\n    }\n    if (!hasObjectProp(ice, \"candidate\")) {\n      console.warn(\"candidate not found in ICE\");\n      return;\n    }\n    try {\n      if (ice.direction === \"send\") {\n        conn.recvPc.addIceCandidate(ice.candidate);\n      } else if (ice.direction === \"recv\") {\n        conn.sendPc.addIceCandidate(ice.candidate);\n      }\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIce(conn, (payload as { ICE?: unknown }).ICE);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"send\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"recv\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      receiveTrack(\n        \"TODO\",\n        setupTrackStopOnLongMute(event.track, conn.recvPc),\n        info\n      );\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    showConnectedStatus();\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs ? myIpfs.pubsub.peers(roomTopic) : [];\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (\n      myIpfs &&\n      connMap.size() === 0 &&\n      lastInitIpfsTime + 3 * 60 * 1000 < Date.now()\n    ) {\n      const prevIpfs = myIpfs;\n      myIpfs = null;\n      myPeerId = null;\n      await closeIpfs(prevIpfs);\n      await sleep(20 * 1000);\n      await initIpfs();\n      return;\n    }\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n\n  let lastInitIpfsTime = 0;\n  const initIpfs = async () => {\n    lastInitIpfsTime = Date.now();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n    const ipfs: IpfsType = await Ipfs.create({\n      repo: secureRandomId(),\n      config: {\n        Addresses: {\n          Swarm: [\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          ],\n        },\n      },\n    });\n    myPeerId = (await ipfs.id()).id;\n    await ipfs.pubsub.subscribe(roomTopic, pubsubHandler);\n    await ipfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    myIpfs = ipfs;\n    if (process.env.NODE_ENV !== \"production\") {\n      (window as any).myIpfs = myIpfs;\n    }\n    checkPeers();\n  };\n  initIpfs();\n\n  const closeIpfs = async (ipfs: IpfsType) => {\n    await ipfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await ipfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await ipfs.stop();\n  };\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    if (mediaType === \"faceAudio\") {\n      // XXX experimental\n      runDispose(trackDisposeMap.get(track));\n      const audioCtx = new AudioContext();\n      const trackSource = audioCtx.createMediaStreamSource(stream);\n      await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n      const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n      const topic = await getTopicForMediaType(roomId, \"faceAudio\");\n      const bufList: ArrayBuffer[] = [];\n      audioEncoder.port.onmessage = async (event) => {\n        bufList.push(event.data);\n        if (bufList.length < 40) return;\n        const encrypted = await encryptBufferFromChunks(\n          bufList.splice(0, bufList.length),\n          cryptoKey\n        );\n        if (myIpfs) {\n          myIpfs.pubsub.publish(topic, encrypted);\n        }\n      };\n      trackSource.connect(audioEncoder);\n      trackDisposeMap.set(track, () => {\n        audioCtx.close();\n      });\n      return;\n    }\n    if (mediaType === \"faceVideo\") {\n      // XXX experimental\n      runDispose(trackDisposeMap.get(track));\n      const topic = await getTopicForMediaType(roomId, \"faceVideo\");\n      const { getImage } = await videoTrackToImageConverter(track);\n      const timer = setInterval(async () => {\n        const dataURL = await getImage();\n        if (dataURL) {\n          const encrypted = await encryptString(\n            JSON.stringify({ dataURL }),\n            cryptoKey\n          );\n          if (myIpfs) {\n            myIpfs.pubsub.publish(topic, encrypted);\n          }\n        }\n      }, 1000);\n      trackDisposeMap.set(track, () => {\n        clearInterval(timer);\n      });\n      return;\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    if (mediaType === \"faceAudio\" || mediaType === \"faceVideo\") {\n      // XXX experimental\n      runDispose(trackDisposeMap.get(track));\n      return;\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective) {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    if (myIpfs) {\n      closeIpfs(myIpfs);\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n"],"sourceRoot":""}