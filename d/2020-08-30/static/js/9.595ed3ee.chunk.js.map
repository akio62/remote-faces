{"version":3,"sources":["utils/sleep.ts","network/trackUtils.ts","../../node_modules/peerjs/dist sync","network/peerjsUtils.ts","network/peerjsRoom.ts","utils/types.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","webpackEmptyContext","req","e","Error","code","keys","module","exports","id","isValidPeerId","roomId","peerId","startsWith","slice","ROOM_ID_PREFIX_LEN","generatePeerId","peerIndex","getPeerIndexFromPeerId","Number","split","getPeerIndexFromConn","conn","peer","createConnectionMap","map","Map","registerRemoteMediaTypeFromSDP","msid2mediaType","sdpLines","mid","value","get","forEach","line","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","markConnected","connected","isConnected","setUserId","userId","getUserId","hasConn","getConn","delConn","delete","getConnectedPeerIds","Array","from","filter","k","forEachConnectedConns","callback","values","forEachConnsAcceptingMedia","includes","clearAll","size","console","log","clear","getRemoteMediaType","registerRemoteMediaType","sdp","hasObjectProp","hasStringProp","guessSeed","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myPeer","connMap","importCryptoKey","cryptoKey","showConnectedStatus","peerIndexList","type","connectPeer","disconnected","connect","initConnection","broadcastData","data","peers","sendPayload","sendData","sendSDP","getMsid2MediaType","SDP","handlePayloadSDP","isObject","peerConnection","syncAllTracks","info","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","x","handlePayloadPeers","handlePayloadData","connUserId","handlePayload","encrypted","JSON","decryptString","payload","parse","encryptString","stringify","send","error","on","buf","iceGatheringState","onicecandidate","negotiationScheduled","mType","reInitMyPeer","waitSec","floor","initMyPeer","index","isSeed","rand4","Peer","getPeerJsConfigFromUrl","i","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","acceptMediaTypes","mTypes","transceivers","getReceivers","readyState","mediaTypeMap","stream","MediaStream","name","removeTrack","item","sender","getSenders","s","senders","some","transport","dispose","prop"],"mappings":"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","file":"static/js/9.595ed3ee.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 487;","import Peer from \"peerjs\";\n\nimport { ROOM_ID_PREFIX_LEN } from \"./common\";\nimport { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (\n    conn: Peer.DataConnection,\n    mediaTypes: string[]\n  ) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected && value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  const getRemoteMediaType = (conn: Peer.DataConnection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Peer.DataConnection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Peer.DataConnection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    hasConn,\n    getConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  rand4,\n  importCryptoKey,\n  encryptString,\n  decryptString,\n} from \"../utils/crypto\";\nimport { getPeerJsConfigFromUrl } from \"../utils/url\";\nimport { isObject, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerjsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendData = (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.getConn(generatePeerId(roomId, peerIndex));\n    if (!conn) return;\n    const peers = connMap.getConnectedPeerIds();\n    sendPayload(conn, { userId, data, peers, mediaTypes });\n  };\n\n  const sendSDP = (\n    conn: Peer.DataConnection,\n    sdp: { offer: unknown } | { answer: unknown }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    sendPayload(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(sdp.offer);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(await decryptString(encrypted, cryptoKey));\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encryptString(JSON.stringify(payload), cryptoKey);\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      const peerIndex = getPeerIndexFromPeerId(conn.peer);\n      notifyNewPeer(peerIndex);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    let negotiationScheduled = false;\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (negotiationScheduled) return;\n      negotiationScheduled = true;\n      await sleep(5000);\n      negotiationScheduled = false;\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        receiveTrack(\n          mType,\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, getPeerJsConfigFromUrl());\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConnectedConns((conn) => {\n        const connUserId = connMap.getUserId(conn);\n        if (connUserId) {\n          const info: PeerInfo = {\n            userId: connUserId,\n            peerIndex: getPeerIndexFromPeerId(conn.peer),\n            mediaTypes: connMap.getAcceptingMediaTypes(conn),\n          };\n          const transceivers = conn.peerConnection.getTransceivers();\n          conn.peerConnection.getReceivers().forEach((receiver) => {\n            const transceiver = transceivers.find(\n              (t) => t.receiver === receiver\n            );\n            const mid = transceiver?.mid;\n            const mType = mid && connMap.getRemoteMediaType(conn, mid);\n            if (!mType) {\n              console.warn(\"failed to find media type from mid\");\n              return;\n            }\n            if (\n              receiver.track.readyState === \"live\" &&\n              !mediaTypes.includes(mType) &&\n              mTypes.includes(mType)\n            ) {\n              receiveTrack(\n                mType,\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            }\n          });\n        }\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.peerConnection.addTrack(track, stream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.peerConnection.addTrack(track, stream);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n"],"sourceRoot":""}