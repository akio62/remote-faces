{"version":3,"sources":["utils/types.ts","network/pubsubUtils.ts","utils/sleep.ts","network/trackUtils.ts","network/pubsubRoom.ts"],"names":["isObject","x","hasStringProp","prop","hasObjectProp","peerIndexCounter","createConnectionMap","map","Map","setAcceptingMediaTypes","conn","mediaTypes","value","get","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","Error","peerIndex","audioWorkers","vidoeSetImages","set","getConn","findConn","Array","from","values","find","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","onmute","timeout","readyState","transceiver","getTransceivers","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","a","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","topicsForMediaTypes","getTopicForMediaType","roomId","mediaType","key","topic","sha256","slice","ROOM_ID_PREFIX_LEN","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","roomTopic","importCryptoKey","cryptoKey","type","Ipfs","create","repo","secureRandomId","config","Addresses","Swarm","myIpfs","id","myPeerId","pubsub","subscribe","msg","pubsubHandler","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","encryptStringToChunks","stringify","publish","Buffer","error","sendPayloadDirectly","broadcastData","data","sendData","mediaTypeDisposeMap","acceptAudioMedia","disposeList","audioHandler","warn","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","e","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","push","terminate","decryptBufferToChunks","byteOffset","byteLength","bufList","buf","postMessage","unshift","unsubscribe","acceptVideoMedia","videoHandler","acceptMediaTypes","mTypes","existingMediaType","includes","dispose","endsWith","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","peerIndexList","checkPeers","peers","length","trackDisposeMap","runDispose","addAudioTrack","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","encryptBufferFromChunks","splice","addVideoTrack","videoDisposed","loop","mediaTypeMap","removeTrack"],"mappings":"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","file":"static/js/10.a7ab237c.chunk.js","sourcesContent":["export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<\n  F extends (...args: any) => any\n> = ReturnType<F> extends Promise<infer T> ? T : never;\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import Ipfs, { PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await Ipfs.create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          // \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 17) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}