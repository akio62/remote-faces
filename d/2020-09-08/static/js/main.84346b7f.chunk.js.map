{"version":3,"sources":["network/common.ts","network/room.ts","utils/url.ts","components/ErrorFallback.tsx","components/SuspenseFallback.tsx","components/SingleRoomEntrance.tsx","components/GitHubCorner.tsx","components/App.tsx","serviceWorker.ts","index.tsx","utils/crypto.ts"],"names":["ROOM_ID_PREFIX_LEN","createRoom","a","hasPeerJsConfigInUrl","createRoomImpl","hasPubsubConfigInUrl","copyHashFromLink","link","srcHash","URL","hash","slice","srcSearchParams","URLSearchParams","dstHash","window","location","dstSearchParams","forEach","value","key","set","toString","e","extractRoomIdFromLink","get","getRoomIdFromUrl","setRoomIdToUrl","roomId","searchParams","has","getPeerJsConfigFromUrl","server","url","secure","protocol","defaultPort","host","split","port","Number","path","pathname","ErrorFallback","React","memo","err","useState","waitSec","setWaitSec","useEffect","setTimeout","reload","name","message","SuspenseFallback","className","Landing","lazy","SingleRoom","roomIdFromUrl","userId","secureRandomId","SingleRoomEntrance","setRoomId","linkShown","setLinkShown","linkText","setLinkText","onCreateNew","generateCryptoKey","type","onClick","onChange","target","placeholder","disabled","GitHubCorner","size","fill","color","href","aria-label","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","ErrorBoundary","state","children","this","props","PureComponent","App","fallback","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","sha256","text","encoder","TextEncoder","data","encode","crypto","subtle","digest","buf","arr","Array","from","Uint8Array","hex","map","b","padStart","join","len","getRandomValues","rand4","Uint16Array","generateKey","length","exportKey","importCryptoKey","usages","i","parseInt","importKey","cryptoKey","encryptBuffer","input","iv","encrypt","encrypted","output","byteLength","buffer","decryptBuffer","byteOffset","decrypt","decrypted","encryptString","encoded","compressed","pako","deflate","decryptString","decompressed","inflate","decoder","TextDecoder","decode","encryptStringToChunks","chunkSize","chunkData","deflator","Deflate","onData","push","id","chunk","of","chunkStore","decryptStringFromChunks","Uint32Array","index","store","find","item","chunks","shift","Error","inflator","Inflate","result","encryptBufferFromChunks","bufferList","totalLength","reduce","accum","concatenated","decryptBufferToChunks","lengthList"],"mappings":"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","file":"static/js/main.84346b7f.chunk.js","sourcesContent":["export const ROOM_ID_PREFIX_LEN = 32;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"SERVER_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\"; err: Error }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype NotifyNewPeer = (peerIndex: number) => void;\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (\n  mediaType: string,\n  track: MediaStreamTrack,\n  info: PeerInfo\n) => void;\n\nexport type CreateRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  notifyNewPeer: NotifyNewPeer,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => Promise<{\n  broadcastData: (data: unknown) => void;\n  sendData: (data: unknown, peerIndex: number) => void;\n  acceptMediaTypes: (mediaTypes: string[]) => void;\n  addTrack: (mediaType: string, track: MediaStreamTrack) => void;\n  removeTrack: (mediaType: string) => void;\n  dispose: () => void;\n}>;\n","import { hasPeerJsConfigInUrl, hasPubsubConfigInUrl } from \"../utils/url\";\nimport type { CreateRoom } from \"./common\";\n\nexport type { NetworkStatus, PeerInfo } from \"./common\";\nexport { ROOM_ID_PREFIX_LEN } from \"./common\";\n\nexport const createRoom: CreateRoom = async (...args) => {\n  let createRoomImpl: CreateRoom;\n  if (hasPeerJsConfigInUrl()) {\n    createRoomImpl = (await import(\"./peerjsRoom\")).createRoom;\n  } else if (hasPubsubConfigInUrl()) {\n    createRoomImpl = (await import(\"./pubsubRoom\")).createRoom;\n  } else {\n    createRoomImpl = (await import(\"./ipfsRoom\")).createRoom;\n  }\n  return createRoomImpl(...args);\n};\n","export const copyHashFromLink = (link: string) => {\n  try {\n    const srcHash = new URL(link).hash.slice(1);\n    const srcSearchParams = new URLSearchParams(srcHash);\n    const dstHash = window.location.hash.slice(1);\n    const dstSearchParams = new URLSearchParams(dstHash);\n    srcSearchParams.forEach((value, key) => {\n      dstSearchParams.set(key, value);\n    });\n    window.location.hash = dstSearchParams.toString();\n  } catch (e) {\n    // ignore\n  }\n};\n\nexport const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n\nexport const hasPeerJsConfigInUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.has(\"peerjs\");\n};\n\nexport const getPeerJsConfigFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const server = searchParams.get(\"peerjs\");\n  try {\n    const url = new URL(server || \"\");\n    const secure = url.protocol === \"https:\";\n    const defaultPort = secure ? 443 : 80;\n    return {\n      host: url.host.split(\":\")[0],\n      port: url.port ? Number(url.port) : defaultPort,\n      path: url.pathname,\n      secure,\n    };\n  } catch (e) {\n    // ignore\n  }\n  return undefined;\n};\n\nexport const hasPubsubConfigInUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.has(\"pubsub\");\n};\n","import React, { useEffect, useState } from \"react\";\n\nexport const ErrorFallback = React.memo<{\n  err: Error;\n}>(({ err }) => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      {err && (\n        <h6>\n          {err.name}: {err.message}\n        </h6>\n      )}\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./SuspenseFallback.css\";\n\nexport const SuspenseFallback = React.memo(() => (\n  <div className=\"Loading-container\">\n    <div>Loading...</div>\n  </div>\n));\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId, generateCryptoKey } from \"../utils/crypto\";\nimport { ROOM_ID_PREFIX_LEN } from \"../network/room\";\nimport {\n  getRoomIdFromUrl,\n  extractRoomIdFromLink,\n  copyHashFromLink,\n} from \"../utils/url\";\n\nconst Landing = React.lazy(() => import(\"./Landing\"));\nconst SingleRoom = React.lazy(() => import(\"./SingleRoom\"));\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nexport const SingleRoomEntrance = React.memo(() => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkShown, setLinkShown] = useState(false);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = async () => {\n    setRoomId(\n      secureRandomId(ROOM_ID_PREFIX_LEN / 2) + (await generateCryptoKey())\n    );\n  };\n\n  const onEnter = () => {\n    copyHashFromLink(linkText);\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-container\">\n      <Landing>\n        <div className=\"SingleRoomEntrance-input\">\n          {!linkShown && (\n            <>\n              <div>\n                <button type=\"button\" onClick={onCreateNew}>\n                  Create a new room\n                </button>\n              </div>\n              <div className=\"SingleRoomEntrance-or\">OR</div>\n              <div>\n                <button type=\"button\" onClick={() => setLinkShown(true)}>\n                  Enter an existing room link\n                </button>\n              </div>\n            </>\n          )}\n          {linkShown && (\n            <div>\n              <input\n                value={linkText}\n                onChange={(e) => setLinkText(e.target.value)}\n                placeholder=\"Enter room link...\"\n              />\n              <button\n                type=\"button\"\n                onClick={onEnter}\n                disabled={!extractRoomIdFromLink(linkText)}\n              >\n                Enter room\n              </button>\n              <button type=\"button\" onClick={() => setLinkShown(false)}>\n                Cancel\n              </button>\n            </div>\n          )}\n        </div>\n      </Landing>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\n// http://tholman.com/github-corners/\nexport const GitHubCorner = React.memo<{\n  size?: number;\n  fill?: string;\n  color?: string;\n}>(({ size, fill, color }) => (\n  <a\n    href=\"https://github.com/dai-shi/remote-faces\"\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n));\n","import React, { Suspense } from \"react\";\n\nimport \"./App.css\";\nimport { ErrorFallback } from \"./ErrorFallback\";\nimport { SuspenseFallback } from \"./SuspenseFallback\";\nimport { SingleRoomEntrance } from \"./SingleRoomEntrance\";\nimport { GitHubCorner } from \"./GitHubCorner\";\n\nclass ErrorBoundary extends React.PureComponent {\n  state: { err?: Error } = {};\n\n  static getDerivedStateFromError(err: Error) {\n    return { err };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { err } = this.state;\n    if (err) return <ErrorFallback err={err} />;\n    return children;\n  }\n}\n\nexport const App = React.memo(() => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <Suspense fallback={<SuspenseFallback />}>\n        <SingleRoomEntrance />\n        <GitHubCorner size={40} fill=\"gray\" />\n      </Suspense>\n    </ErrorBoundary>\n  </div>\n));\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import pako from \"pako\";\n\nexport const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = (len = 32) => {\n  const buf = window.crypto.getRandomValues(new Uint8Array(len));\n  const arr = Array.from(buf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n\nexport const generateCryptoKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  );\n  const buf = await window.crypto.subtle.exportKey(\"raw\", key);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const importCryptoKey = async (\n  key: string,\n  usages: (\"encrypt\" | \"decrypt\")[] = [\"encrypt\", \"decrypt\"]\n) => {\n  const size = key.length / 2;\n  const buf = new Uint8Array(size);\n  for (let i = 0; i < size; i += 1) {\n    buf[i] = parseInt(key.slice(i * 2, i * 2 + 2), 16);\n  }\n  const cryptoKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    buf,\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    usages\n  );\n  return cryptoKey;\n};\n\nexport const encryptBuffer = async (\n  input: ArrayBuffer,\n  key: CryptoKey\n): Promise<ArrayBuffer> => {\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encrypted = await window.crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv },\n    key,\n    input\n  );\n  const output = new Uint8Array(iv.length + encrypted.byteLength);\n  output.set(iv);\n  output.set(new Uint8Array(encrypted), iv.length);\n  return output.buffer;\n};\n\nexport const decryptBuffer = async (\n  input: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number,\n  key: CryptoKey\n): Promise<ArrayBuffer> => {\n  const decrypted = await window.crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: input.slice(byteOffset, byteOffset + 12) },\n    key,\n    input.slice(byteOffset + 12, byteOffset + byteLength)\n  );\n  return decrypted;\n};\n\n// encrypt with compression\nexport const encryptString = async (data: string, cryptoKey: CryptoKey) => {\n  const encoder = new TextEncoder();\n  const encoded = encoder.encode(data);\n  const compressed = pako.deflate(encoded);\n  return encryptBuffer(compressed, cryptoKey);\n};\n\n// decrypt with decompression\nexport const decryptString = async (buf: ArrayBuffer, cryptoKey: CryptoKey) => {\n  const decrypted = await decryptBuffer(buf, 0, buf.byteLength, cryptoKey);\n  const decompressed = pako.inflate(new Uint8Array(decrypted));\n  const decoder = new TextDecoder(\"utf-8\");\n  const data = decoder.decode(decompressed);\n  return data;\n};\n\n// encrypt into chunks\nexport async function* encryptStringToChunks(\n  data: string,\n  cryptoKey: CryptoKey,\n  chunkSize = 60000\n) {\n  const encoder = new TextEncoder();\n  const encoded = encoder.encode(data);\n  const chunkData: Uint8Array[] = [];\n  const deflator = new pako.Deflate({ chunkSize });\n  deflator.onData = (d: Uint8Array) => {\n    chunkData.push(d);\n  };\n  deflator.push(encoded, true);\n  const len = chunkData.length;\n  const id = window.crypto.getRandomValues(new Uint8Array(4));\n  for (let i = 0; i < len; i += 1) {\n    const chunk = new Uint8Array(4 + 2 + 2 + chunkData[i].byteLength);\n    chunk.set(id);\n    chunk.set(new Uint8Array(Uint16Array.of(i).buffer), 4);\n    chunk.set(new Uint8Array(Uint16Array.of(len).buffer), 4 + 2);\n    chunk.set(chunkData[i], 4 + 2 + 2);\n    yield encryptBuffer(chunk, cryptoKey);\n  }\n}\n\nconst chunkStore: {\n  id: number;\n  len: number;\n  chunks: ArrayBuffer[];\n}[] = [];\n\nconst MAX_CHUNK_STORE_SIZE = 100;\n\n// decrypt from chunks\nexport const decryptStringFromChunks = async (\n  buf: ArrayBuffer,\n  cryptoKey: CryptoKey\n) => {\n  const chunk = await decryptBuffer(buf, 0, buf.byteLength, cryptoKey);\n  const id = new Uint32Array(chunk, 0, 4)[0];\n  const index = new Uint16Array(chunk, 4, 2)[0];\n  const len = new Uint16Array(chunk, 4 + 2, 2)[0];\n  let store = chunkStore.find((item) => item.id === id);\n  if (!store) {\n    store = { id, len, chunks: [] };\n    chunkStore.push(store);\n    if (chunkStore.length > MAX_CHUNK_STORE_SIZE) {\n      chunkStore.shift();\n    }\n  } else if (store.len !== len) {\n    throw new Error(\"chunk len mismatch\");\n  }\n  store.chunks[index] = chunk;\n  for (let i = 0; i < len; i += 1) {\n    if (!store.chunks[i]) {\n      // not all chunks are ready\n      return null;\n    }\n  }\n  const inflator = new pako.Inflate();\n  for (let i = 0; i < len; i += 1) {\n    inflator.push(new Uint8Array(store.chunks[i], 4 + 2 + 2), i === len - 1);\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const data = decoder.decode(inflator.result as Uint8Array);\n  return data;\n};\n\n// encrypt from buffer chunks\nexport const encryptBufferFromChunks = (\n  bufferList: ArrayBuffer[],\n  cryptoKey: CryptoKey\n) => {\n  const totalLength =\n    (bufferList.length + 1) * 2 +\n    bufferList.reduce((accum, buffer) => accum + buffer.byteLength, 0);\n  const concatenated = new Uint8Array(totalLength);\n  let index = 0;\n  bufferList.forEach((buffer) => {\n    if (buffer.byteLength === 0) throw new Error(\"buffer is empty\");\n    concatenated.set(\n      new Uint8Array(Uint16Array.of(buffer.byteLength).buffer),\n      index\n    );\n    index += 2;\n  });\n  concatenated.set(new Uint8Array(Uint16Array.of(0).buffer), index);\n  index += 2;\n  bufferList.forEach((buffer) => {\n    concatenated.set(new Uint8Array(buffer), index);\n    index += buffer.byteLength;\n  });\n  return encryptBuffer(concatenated, cryptoKey);\n};\n\n// decrypt to buffer chunks\nexport const decryptBufferToChunks = async (\n  input: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number,\n  cryptoKey: CryptoKey\n) => {\n  const decrypted = await decryptBuffer(\n    input,\n    byteOffset,\n    byteLength,\n    cryptoKey\n  );\n  const lengthList: number[] = [];\n  let index = 0;\n  while (index < decrypted.byteLength) {\n    const len = new Uint16Array(decrypted, index, 2)[0];\n    index += 2;\n    if (len === 0) break;\n    lengthList.push(len);\n  }\n  const bufferList: ArrayBuffer[] = [];\n  lengthList.forEach((len) => {\n    bufferList.push(decrypted.slice(index, index + len));\n    index += len;\n  });\n  return bufferList;\n};\n"],"sourceRoot":""}