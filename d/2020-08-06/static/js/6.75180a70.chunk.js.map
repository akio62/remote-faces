{"version":3,"sources":["utils/sleep.ts","utils/types.ts","network/trackUtils.ts","network/ipfsUtils.ts","network/ipfsRoom.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","isObject","x","hasStringProp","prop","hasObjectProp","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","createConnectionMap","map","Map","setMediaTypes","conn","mediaTypes","value","get","peer","getMediaTypes","addConn","peerId","userId","Error","peerIndex","sendPc","recvPc","getConn","findConn","Array","from","values","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","forEachConnsAcceptingMedia","mediaType","includes","size","createRoom","roomId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myIpfs","myPeerId","connMap","localStream","roomTopic","slice","ROOM_ID_PREFIX_LEN","importCryptoKey","cryptoKey","showConnectedStatus","peerIndexList","type","parsePayload","encrypted","JSON","decrypt","payload","parse","console","log","info","undefined","sendPayload","topic","encrypt","stringify","byteLength","warn","pubsub","publish","error","sendPayloadDirectly","noop","subscribe","unsubscribe","broadcastData","data","sendData","acceptMediaTypes","mTypes","length","MediaStream","getReceivers","readyState","sendSDP","sdp","SDP","handlePayloadSDP","negotiationId","negotiationIdMap","startNegotiation","running","secureRandomId","negotiate","sendIce","ice","ICE","handlePayloadIce","direction","e","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","syncAllTracks","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","pubsubHandler","msg","checkPeers","peers","lastInitIpfsTime","Date","now","prevIpfs","closeIpfs","initIpfs","Ipfs","create","repo","config","Addresses","Swarm","ipfs","id","trackMediaTypeMap","name","removeTrack","sender","getSenders","s","senders","getTracks","mType","dispose"],"mappings":"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","file":"static/js/6.75180a70.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <Prop extends string>(\n  x: object,\n  prop: Prop\n): x is object & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <Prop extends string>(\n  x: object,\n  prop: Prop\n): x is object & Record<Prop, object> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, { conn, mediaTypes: [] });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.mediaTypes && value.mediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setMediaTypes,\n    getMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n  };\n};\n","import Ipfs, { IpfsType, PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  secureRandomId,\n  importCryptoKey,\n  encrypt,\n  decrypt,\n} from \"../utils/crypto\";\nimport { isObject, hasStringProp, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myIpfs: IpfsType | null = null;\n  let myPeerId: string | null = null;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const payload = JSON.parse(await decrypt(encrypted, cryptoKey));\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      const encrypted = await encrypt(JSON.stringify(payload), cryptoKey);\n      console.log(\"sending encrypted\", encrypted.byteLength);\n      if (encrypted.byteLength > 262144) {\n        console.warn(\"encrypted message too large, aborting\");\n        return;\n      }\n      if (!myIpfs) {\n        console.warn(\"no myIpfs initialized\");\n        return;\n      }\n      await myIpfs.pubsub.publish(topic, encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // HACK somehow, publish doesn't work without this\n    if (myIpfs) {\n      const noop = () => null;\n      await myIpfs.pubsub.subscribe(topic, noop);\n      await myIpfs.pubsub.unsubscribe(topic, noop);\n    }\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConns((conn) => {\n          const info: PeerInfo = {\n            userId: conn.userId,\n            peerIndex: conn.peerIndex,\n            mediaTypes: connMap.getMediaTypes(conn),\n          };\n          conn.recvPc.getReceivers().forEach((receiver) => {\n            if (receiver.track.readyState !== \"live\") return;\n            receiveTrack(\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          });\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const sendSDP = async (\n    conn: Connection,\n    sdp:\n      | {\n          negotiationId: string;\n          offer: RTCSessionDescriptionInit;\n        }\n      | {\n          negotiationId: string;\n          answer: RTCSessionDescriptionInit;\n        }\n  ) => {\n    await sendPayloadDirectly(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (!hasStringProp(sdp, \"negotiationId\")) {\n      console.warn(\"negotiationId not found in SDP\");\n      return;\n    }\n    const { negotiationId } = sdp;\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.recvPc.setRemoteDescription(sdp.offer);\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { negotiationId, answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      if (negotiationIdMap.get(conn) === negotiationId) {\n        negotiationIdMap.delete(conn);\n      }\n      try {\n        await conn.sendPc.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const negotiationIdMap = new WeakMap<Connection, string>();\n  const startNegotiation = (conn: Connection) => {\n    const running = negotiationIdMap.has(conn);\n    negotiationIdMap.set(conn, secureRandomId());\n    if (running) return;\n    const negotiate = async () => {\n      const negotiationId = negotiationIdMap.get(conn);\n      if (!negotiationId) return;\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      await sendSDP(conn, { negotiationId, offer });\n      await sleep(5000);\n      negotiate();\n    };\n    negotiate();\n  };\n\n  const sendIce = (\n    conn: Connection,\n    ice: {\n      direction: \"send\" | \"recv\";\n      candidate: RTCIceCandidate;\n    }\n  ) => {\n    sendPayloadDirectly(conn, { ICE: ice });\n  };\n\n  const handlePayloadIce = (conn: Connection, ice: unknown) => {\n    if (!isObject(ice)) return;\n    if (!hasStringProp(ice, \"direction\")) {\n      console.warn(\"direction not found in ICE\");\n      return;\n    }\n    if (!hasObjectProp(ice, \"candidate\")) {\n      console.warn(\"candidate not found in ICE\");\n      return;\n    }\n    try {\n      if (ice.direction === \"send\") {\n        conn.recvPc.addIceCandidate(ice.candidate);\n      } else if (ice.direction === \"recv\") {\n        conn.sendPc.addIceCandidate(ice.candidate);\n      }\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIce(conn, (payload as { ICE?: unknown }).ICE);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"send\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"recv\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      receiveTrack(setupTrackStopOnLongMute(event.track, conn.recvPc), info);\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    showConnectedStatus();\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs ? myIpfs.pubsub.peers(roomTopic) : [];\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (\n      myIpfs &&\n      connMap.size() === 0 &&\n      lastInitIpfsTime + 3 * 60 * 1000 < Date.now()\n    ) {\n      const prevIpfs = myIpfs;\n      myIpfs = null;\n      myPeerId = null;\n      await closeIpfs(prevIpfs);\n      await sleep(20 * 1000);\n      await initIpfs();\n      return;\n    }\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n\n  let lastInitIpfsTime = 0;\n  const initIpfs = async () => {\n    lastInitIpfsTime = Date.now();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n    const ipfs: IpfsType = await Ipfs.create({\n      repo: secureRandomId(),\n      config: {\n        Addresses: {\n          Swarm: [\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          ],\n        },\n      },\n    });\n    myPeerId = (await ipfs.id()).id;\n    await ipfs.pubsub.subscribe(roomTopic, pubsubHandler);\n    await ipfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    myIpfs = ipfs;\n    if (process.env.NODE_ENV !== \"production\") {\n      (window as any).myIpfs = myIpfs;\n    }\n    checkPeers();\n  };\n  initIpfs();\n\n  const closeIpfs = async (ipfs: IpfsType) => {\n    await ipfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await ipfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await ipfs.stop();\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.sendPc.addTrack(track, localStream);\n        startNegotiation(conn);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.sendPc.addTrack(track, localStream);\n          startNegotiation(conn);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.sendPc.removeTrack(sender);\n          startNegotiation(conn);\n        }\n      }\n    });\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    if (myIpfs) {\n      closeIpfs(myIpfs);\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}