{"version":3,"sources":["utils/sleep.ts","utils/types.ts","network/trackUtils.ts","../../node_modules/peerjs/dist sync","network/peerjsUtils.ts","network/peerjsRoom.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","isObject","x","hasStringProp","prop","hasObjectProp","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","webpackEmptyContext","req","e","Error","code","keys","module","exports","id","isValidPeerId","roomId","peerId","startsWith","slice","ROOM_ID_PREFIX_LEN","generatePeerId","peerIndex","getPeerIndexFromPeerId","Number","split","getPeerIndexFromConn","conn","peer","createConnectionMap","map","Map","addConn","value","get","mediaTypes","markConnected","connected","isConnected","setUserId","userId","getUserId","setMediaTypes","getMediaTypes","hasConn","getConn","delConn","delete","getConnectedPeerIds","Array","from","filter","k","forEachConnectedConns","callback","values","forEach","forEachConnsAcceptingMedia","mediaType","includes","clearAll","size","console","log","clear","guessSeed","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myPeer","connMap","localStream","importCryptoKey","cryptoKey","showConnectedStatus","peerIndexList","type","connectPeer","disconnected","connect","initConnection","broadcastData","data","peers","sendPayload","sendData","sendSDP","sdp","SDP","handlePayloadSDP","peerConnection","syncAllTracks","info","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadPeers","handlePayloadData","connUserId","handlePayload","encrypted","JSON","decrypt","payload","parse","encrypt","stringify","send","error","scheduledNegotiation","on","buf","iceGatheringState","onicecandidate","length","reInitMyPeer","waitSec","floor","initMyPeer","index","isSeed","rand4","Peer","getPeerJsConfigFromUrl","i","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","acceptMediaTypes","mTypes","MediaStream","getReceivers","readyState","trackMediaTypeMap","name","removeTrack","sender","getSenders","s","senders","getTracks","mType","some","transport","dispose"],"mappings":"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","file":"static/js/8.bf642f55.chunk.js","sourcesContent":["export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <Prop extends string>(\n  x: object,\n  prop: Prop\n): x is object & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <Prop extends string>(\n  x: object,\n  prop: Prop\n): x is object & Record<Prop, object> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 481;","import Peer from \"peerjs\";\n\nimport { ROOM_ID_PREFIX_LEN } from \"./common\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, mediaTypes: [] });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setMediaTypes = (conn: Peer.DataConnection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (\n        value.connected &&\n        value.mediaTypes &&\n        value.mediaTypes.includes(mediaType)\n      ) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setMediaTypes,\n    getMediaTypes,\n    hasConn,\n    getConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { rand4, importCryptoKey, encrypt, decrypt } from \"../utils/crypto\";\nimport { getPeerJsConfigFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerjsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendData = (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.getConn(generatePeerId(roomId, peerIndex));\n    if (!conn) return;\n    const peers = connMap.getConnectedPeerIds();\n    sendPayload(conn, { userId, data, peers, mediaTypes });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    sendPayload(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(await decrypt(encrypted, cryptoKey));\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(JSON.stringify(payload), cryptoKey);\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const scheduledNegotiation = new WeakMap<Peer.DataConnection, boolean>();\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      const peerIndex = getPeerIndexFromPeerId(conn.peer);\n      notifyNewPeer(peerIndex);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, getPeerJsConfigFromUrl());\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConnectedConns((conn) => {\n          const connUserId = connMap.getUserId(conn);\n          if (connUserId) {\n            const info: PeerInfo = {\n              userId: connUserId,\n              peerIndex: getPeerIndexFromPeerId(conn.peer),\n              mediaTypes: connMap.getMediaTypes(conn),\n            };\n            conn.peerConnection.getReceivers().forEach((receiver) => {\n              if (receiver.track.readyState !== \"live\") return;\n              receiveTrack(\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            });\n          }\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}